
---
title: "CPUE ANALYSIS"
author: "Danny Cooper"
date: January 2018
csl: Format/ecology.csl
output:
  word_document:
    fig_caption: yes
    reference_docx: markdown_reference.docx
    toc: yes
bibliography: Format/library.bib
---
```{r echo = FALSE, warning = FALSE, message = FALSE, results = "hide"}
#===============================================================
#===============================================================
# Danny Cooper
# IPHC Data Analysis

# Install/load necessary packages

libs<-c("plyr","reshape","rmarkdown","knitr","boot", "ggplot2")
if(length(libs[which(libs %in% rownames(installed.packages()) == FALSE )])>0){
  install.packages(libs[which(libs %in% rownames(installed.packages()) == FALSE )])
  }
lapply(libs,library,character.only=T)

options(scipen = 20)

# Import relevant files (hook census and hook data files)

catch_data <- read.csv("IPHC_Data/IPHC_hook_census.csv", na.strings = "", header = TRUE)

colnames(catch_data)[8] <- "cmnnme_1"

station_data <- read.csv("IPHC_Data/Hook_Data2.csv", na.strings = "", header = TRUE)

# Reformat the values of the second species number to 0's

catch_data$secspcno[catch_data$secspcno == "NULL"] <- NA

catch_data$secspcno <- as.numeric(catch_data$secspcno)

catch_data$secspcno[is.na(catch_data$secspcno)] <- 0

# Calculate the percent of secondary catch relative to primary catch and 
# number of hooks and total number of hooks

hook_total <- nrow(catch_data)

catch_amount <- catch_data[catch_data$cmnnme != "Inanimate Object" & 
    catch_data$cmnnme != "Missing Hook/Gangion" & catch_data$cmnnme != 
    "Hook with Skin" & catch_data$cmnnme != "Hook with Bait" & catch_data$cmnnme 
    != "Empty Hook" & catch_data$cmnnme != "Bent Hook" & catch_data$cmnnme != 
    "Bent/Broken/Missing" & catch_data$cmnnme != "unident. organic matter",]

catch_percent <- (nrow(catch_amount[catch_amount$secspcno != 0, ]) / 
    nrow(catch_amount)) * 100 #gives the % of hooks with catch that had more than one fish

all_percent <- (nrow(catch_data[catch_data$secspcno != 0, ]) / 
    nrow(catch_data)) * 100 #gives the % of all hooks with more than one fish/item

sec_percent <- cbind(all_percent, catch_percent)

colnames(sec_percent) <- c("multi_All_Hooks", "multi_catch_Hooks") 

# Subset the hook data file to contain only desired columns and rename them

hook_data <- subset(station_data, select = c("yr", "station", "hksretriev", "hksobs", "ineffhks"))

colnames(hook_data) <- c("Year", "Station", "hksretriev", "hksobs", "ineffhks")

# Insert new column into the hook data for the total number of ineffective 
# hooks

hook_data$totineffhks <- hook_data$ineffhks / hook_data$hksobs * hook_data$hksretriev

# Split the dates into separate columns to create a column for the year

catch_data$yr <- lapply(strsplit(as.character(catch_data$Date), "\\/"), "[", 3)

catch_data$yr <- as.numeric(catch_data$yr)

# Insert a catch row to be summed for each species later

catch_data$Catch <- rep(1, nrow(catch_data))

# Insert the primary catch data into any row containing a 0 in secondary 
# catch and do the same for the common name

catch_data$secspcno <- ifelse(catch_data$secspcno == 0, catch_data$prispcno, 
    catch_data$secspcno)

catch_data$cmnnme <- as.character(catch_data$cmnnme)

catch_data$cmnnme_1 <- as.character(catch_data$cmnnme_1)

catch_data[catch_data$cmnnme_1 == "NULL", "cmnnme_1"]  <- catch_data[catch_data$cmnnme_1 == "NULL", "cmnnme"]

# Select the relevant data from this new dataset to divide the primary and
# secondary catches and sum each of the columns to calculate the catch for 
# each species by station and year

pri_data <- subset(catch_data, select = c("Station", "yr", "cmnnme", "Catch"))

pri_catch <- ddply(pri_data, c("Station", "yr", "cmnnme"), 
    numcolwise(sum))

sec_data <- subset(catch_data, select = c("Station", "yr", "cmnnme_1", 
    "Catch"))

sec_catch <- ddply(sec_data, c("Station", "yr", "cmnnme_1"), 
    numcolwise(sum))

# Combine these datasets to give the primary and secondary catch for each
# species by station and year; set any remaining missing values to 0; rename
# each column

catch_all <- merge(pri_catch, sec_catch, by.x = c("Station", "yr", "cmnnme"),
    by.y = c("Station", "yr", "cmnnme_1"), all = TRUE)

catch_all[is.na(catch_all)] <- 0

colnames(catch_all) <- c("Station", "Year", "Common_Name", "Primary_Catch", 
    "Secondary_Catch")

# Combine this dataset with the hook data by station and year to provide
# the catch and number of ineffective hooks for each station and year

catch_hook <- merge(catch_all, hook_data, by = c("Station", "Year"), 
    all.x = T) 

# Extrapolate the amount of catch to the entire line of hooks and calculate
# the CPUE

catch_hook$Est_Primary_Catch <- catch_hook$hksretriev / catch_hook$hksobs * catch_hook$Primary_Catch

catch_hook$Est_Secondary_Catch <- catch_hook$hksretriev / catch_hook$hksobs * catch_hook$Secondary_Catch

catch_hook$Primary_CPUE <- catch_hook$Est_Primary_Catch / (catch_hook$hksretriev - catch_hook$totineffhks)

catch_hook$Secondary_CPUE <- catch_hook$Est_Secondary_Catch / (catch_hook$hksretriev - catch_hook$totineffhks)

# Select the desired data from this dataset (CPUE, station, year, and species)

CPUE_data <- catch_hook[, c("Station", "Year", "Common_Name", "Primary_CPUE", "Secondary_CPUE")] 

# Remove NA's and NULL values from the dataset

CPUE_data <- CPUE_data[complete.cases(CPUE_data), ]

# Remove categories not of interest and combine other categories together

CPUE_data <- subset(CPUE_data, CPUE_data[, 3] != "Inanimate Object" & CPUE_data[, 3] != "Missing Hook/Gangion" & CPUE_data[, 3] != "Hook with Skin" & CPUE_data[, 3] != "Hook with Bait" & CPUE_data[, 3] != "Empty Hook" & CPUE_data[, 3] != "Bent Hook" & CPUE_data[, 3] != "Bent/Broken/Missing" & CPUE_data[, 3] != "unident. organic matter" & CPUE_data[, 3] != "Unknown/Unspecified")

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. thornyhead (Idiot)"] <- "Thornyhead"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Shortspine Thornyhead"] <- "Thornyhead"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sunflower Sea Star"] <- "Starfish"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Starfish"] <- "Starfish"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Coral"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Sponge"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Anemone"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Gastropod"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Red Tree Coral"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Barnacles"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Cucumber"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Brown King Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Tanner Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Box Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Red King Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Whip"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Urchin"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Shells"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Rougheye/Shortraker"] <- "Rougheye Shortraker"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Greenland/Kamchatka/Arrowtooth"] <- "Greenland Kamchatka Arrowtooth"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Kamchatka/Arrowtooth"] <- "Kamchatka Arrowtooth"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Bering/Alaska Skate"] <- "Bering Alaska Skate"

# Prepare any objects for use inside the for-loop

unq_key <- unique(CPUE_data[,c("Year", "Common_Name")])

Y <- length(unique(unq_key$Year))

I <- length(unique(unq_key$Common_Name))

Results <- matrix(ncol = Y, nrow = I)

Small <- matrix(ncol = Y, nrow = I)

Significant <- matrix(ncol = Y, nrow = I)

Sample <- matrix(ncol = Y, nrow = I)

Test <- matrix(ncol = Y, nrow = I)

mymeans <- matrix(ncol = Y, nrow = I)

mymeans2 <- matrix(ncol = Y, nrow = I)

CPUE_rank <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int <- array(dim = c(I,5,Y))

conf_int2 <- array(dim = c(I,5,Y))

CPUE_subset <- CPUE_data

# Create scatterplots, QQ-plots, perform the Welch's T-Test on ranks, and
# create bootstrapped confidence intervals for each species

for(i in 1:nrow(unq_key)){
  spec <- unq_key[i, 2]
  year <- unq_key[i, 1]
  row <- match(spec, unique(unq_key$Common_Name))
  col <- match(year, unique(unq_key$Year))
  CPUE_spec <- CPUE_data[CPUE_data$Year == year & CPUE_data$Common_Name == spec,]
  if(all(CPUE_spec$Primary_CPUE == CPUE_spec$Secondary_CPUE)){
    CPUE_subset[CPUE_data$Year == year & CPUE_data$Common_Name == spec,] <- NA
    next
  }
  png(paste("IPHC_Data/Plots/", spec, year,".png", sep = ""))
    plot(CPUE_spec$Primary_CPUE, CPUE_spec$Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(CPUE_spec$Primary_CPUE) + .001), ylim = 
        c(0, max(CPUE_spec$Secondary_CPUE) + .001), main = 
        paste("Plot of", spec,year))
    abline(a = 0, b = 1, lty = 3)
    dev.off()
    Sample[row, col] <- nrow(CPUE_spec)
    if(nrow(CPUE_spec) == 1) {
    Small[row, col] <- paste("Small Sample Size")
    next
    } else {
    mymean <- function(Primary_CPUE, j) mean(Primary_CPUE[j])
    myboot <- with(CPUE_spec, boot(Primary_CPUE, mymean, R = 1000))
    if(sd(myboot$t) != 0){
    boot_conf <- boot.ci(myboot, type = "bca")
    conf_int[row, ,col] <- boot_conf$bca
    }
    mymeans[row, col] <- myboot$t0
    mymean2 <- function(Secondary_CPUE, j) mean(Secondary_CPUE[j])
    myboot2 <- with(CPUE_spec, boot(Secondary_CPUE, mymean2, R = 1000))
    if(sd(myboot2$t) != 0){
    boot_conf2 <- boot.ci(myboot2, type = "bca")
    conf_int2[row, ,col] <- boot_conf2$bca
    }
    mymeans2[row, col] <- myboot2$t0
    model <- lm(formula = Secondary_CPUE ~ Primary_CPUE, data = CPUE_spec)
    jpeg(paste("IPHC_Data/Plots/QQof",spec,year,".jpg", sep = ""))
    layout(rbind(c(1,2), c(3,3)))
    qqnorm(CPUE_spec$Primary_CPUE, ylim = c(-0.5,0.5), main = 
        "QQ-plot of Primary CPUE \n", row, col)
    qqline(CPUE_spec$Primary_CPUE, lty = 3)
    qqnorm(CPUE_spec$Secondary_CPUE, ylim = c(-0.5,0.5), main = 
        "QQ-plot of Secondary CPUE \n", row, col)
    qqline(CPUE_spec$Secondary_CPUE, lty = 3)
    qqnorm(residuals(model), ylim = c(-0.5,0.5),
        main = "QQ-plot of Residuals obtained from \nSimple Regression",
        "Model \n", row, col)
    qqline(residuals(model), lty = 3)
    dev.off()
    if(sd(myboot$t) != 0 | sd(myboot2$t) != 0){
    CPUE_rank <- melt(CPUE_spec, id.vars = c("Station", "Year", 
        "Common_Name"))
    colnames(CPUE_rank) <- c("Station", "Year", "Common_Name", "Type", "CPUE")
    CPUE_rank$CPUE <- with(CPUE_rank, rank(CPUE, ties.method = "average"))
    CPUE_rank <- cast(CPUE_rank, Station + Year + Common_Name ~ Type, 
        value = "CPUE")
    result <- with(CPUE_rank, t.test(Primary_CPUE, Secondary_CPUE, var.equal =
    FALSE))
    if (result$p.value < 0.05) {
    Significant[row, col] <- paste("Different Means")
        } else {
        Significant[row, col] <- paste("Similar Means")}
    Results[row, col] <- result$p.value
    }
}}

# Format all of the results into various dataframes for output into an Word
# table

CPUE_subset <- CPUE_subset[complete.cases(CPUE_subset),]

colnames(Results) <- unique(unq_key$Year)

rownames(Results) <- unique(unq_key$Common_Name)

Results <- melt(Results)

colnames(Results) <- c("Species", "Year", "p-value")

colnames(Small) <- unique(unq_key$Year)

rownames(Small) <- unique(unq_key$Common_Name)

Small <- melt(Small)

colnames(Small) <- c("Species", "Year", "Warning")

colnames(Sample) <- unique(unq_key$Year)

rownames(Sample) <- unique(unq_key$Common_Name)

Sample <- melt(Sample)

colnames(Sample) <- c("Species", "Year", "Sample Size")

colnames(Significant) <- unique(unq_key$Year)

rownames(Significant) <- unique(unq_key$Common_Name)

Significant <- melt(Significant)

colnames(Significant) <- c("Species", "Year", "Significance")

colnames(mymeans) <- unique(unq_key$Year)

rownames(mymeans) <- unique(unq_key$Common_Name)

mymeans <- melt(mymeans)

colnames(mymeans) <- c("Species", "Year", "Primary Mean CPUE")

colnames(mymeans2) <- unique(unq_key$Year)

rownames(mymeans2) <- unique(unq_key$Common_Name)

mymeans2 <- melt(mymeans2)

colnames(mymeans2) <- c("Species", "Year", "Secondary Mean CPUE")

Significant_Results <- merge(Results, Significant, by = c("Species", "Year"), all = TRUE)

Small_Sample <- merge(Small, Sample, by = c("Species", "Year"), all = TRUE)

Results <- merge(Significant_Results, Small_Sample, by = c("Species", "Year"), all = TRUE)

Results <- Results[!(is.na(Results$`p-value`)) | !(is.na(Results$Significance)) | !(is.na(Results$Warning)) | !(is.na(Results$`Sample Size`)), ]

Significant <- subset(Significant_Results, Significant == "Different Means")

if(nrow(Significant) > 0) {Significant <- subset(Significant, select = c("Species", "Year", "p-value"))}

conf_names <- colnames(summary(boot_conf$bca))

Common_Names <- unique(unq_key$Common_Name)

year_names <- unique(unq_key$Year)

dimnames(conf_int)[[1]] <- as.character(unlist(Common_Names))

dimnames(conf_int)[[2]] <- as.character(unlist(conf_names))

dimnames(conf_int)[[3]] <- as.character(unlist(year_names))

conf_int <- as.data.frame(as.table(conf_int))

conf_int <- cast(conf_int, Var1 + Var3 ~ Var2, value = "Freq")

conf_int <- conf_int[c(1, 2, 6, 7)]

colnames(conf_int) <- c("Species", "Year", "Primary Lower CPUE", "Primary Upper CPUE")

dimnames(conf_int2)[[1]] <- as.character(unlist(Common_Names))

dimnames(conf_int2)[[2]] <- as.character(unlist(conf_names))

dimnames(conf_int2)[[3]] <- as.character(unlist(year_names))

conf_int2 <- as.data.frame(as.table(conf_int2))

conf_int2 <- cast(conf_int2, Var1 + Var3 ~ Var2, value = "Freq")

conf_int2 <- conf_int2[c(1, 2, 6, 7)]

colnames(conf_int2) <- c("Species", "Year", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int_all <- merge(conf_int, conf_int2, by = c("Species", "Year"), all = TRUE)

Means <- merge(mymeans, mymeans2, by = c("Species", "Year"), all = TRUE)

conf_int_all <- merge(conf_int_all, Means, by = c("Species", "Year"), all = TRUE)

conf_int_all <- na.omit(conf_int_all)

conf_int_all$`Primary Mean CPUE` <- round(conf_int_all$`Primary Mean CPUE`, 3)

conf_int_all$`Primary Lower CPUE` <- round(conf_int_all$`Primary Lower CPUE`, 3)

conf_int_all$`Primary Upper CPUE` <- round(conf_int_all$`Primary Upper CPUE`, 3)

conf_int_all$`Secondary Mean CPUE` <- round(conf_int_all$`Secondary Mean CPUE`, 3)

conf_int_all$`Secondary Lower CPUE` <- round(conf_int_all$`Secondary Lower CPUE`, 3)

conf_int_all$`Secondary Upper CPUE` <- round(conf_int_all$`Secondary Upper CPUE`, 3)

conf_int_all$`Primary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Primary Mean CPUE`, " (", conf_int_all$`Primary Lower CPUE`, ", ", conf_int_all$`Primary Upper CPUE`, ")", sep = "")

conf_int_all$`Secondary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Secondary Mean CPUE`, " (", conf_int_all$`Secondary Lower CPUE`, ", ", conf_int_all$`Secondary Upper CPUE`, ")", sep = "")

conf_int_all <- subset(conf_int_all, select = c("Species", "Year", "Primary Mean CPUE (Lower Bound, Upper Bound)", "Secondary Mean CPUE (Lower Bound, Upper Bound)"))

# Calculate the bootstrapped difference-of-means confidence intervals for
# each species and year

boot_data <- melt(CPUE_subset, id.vars = c("Station", "Year", "Common_Name"))

colnames(boot_data) <- c("Station", "Year", "Common_Name", "Type", "CPUE")

diff.means <- function(d, f)
{    n <- nrow(d)
     tp1 <- 1:table(as.numeric(d$Type))[1]
     m1 <- sum(d[tp1, 5] * f[tp1])/sum(f[tp1])
     m2 <- sum(d[-tp1, 5] * f[-tp1])/sum(f[-tp1])
     ss1 <- sum(d[tp1, 5]^2 * f[tp1]) - (m1 * m1 * sum(f[tp1]))
     ss2 <- sum(d[-tp1, 5]^2 * f[-tp1]) - (m2 * m2 * sum(f[-tp1]))
     c(m1 - m2, (ss1 + ss2)/(sum(f) - 2))
}

unq_key <- unique(boot_data[,c("Year", "Common_Name")])

I <- length(unique(boot_data$Common_Name))

Y <- length(unique(boot_data$Year))

boot_result <- array(dim = c(I, 5, Y))

mean_boot <- matrix(ncol = Y, nrow = I)

for(i in 1:nrow(unq_key)){
  spec <- unq_key[i, 2]
  year <- unq_key[i, 1]
  row <- match(spec, unique(unq_key$Common_Name))
  col <- match(year, unique(unq_key$Year))
  boot_spec <- boot_data[boot_data$Year == year & boot_data$Common_Name == spec,]
  boot_spec <- na.omit(boot_spec)
  if (nrow(boot_spec) < 3) {next}
  type_boot <- boot(boot_spec, diff.means, R = 1000, strata = 
      boot_spec[ ,5])
  if(sd(type_boot$t[, 1]) != 0 & sd(type_boot$t[, 2]) != 0){
  boot_test <- boot.ci(type_boot, type = "perc")
  boot_result[row, , col] <- boot_test$perc
  }
  mean_boot[row, col] <- type_boot$t0[1]
}

# Format these results as a dataframe for output to Word

conf_name <- colnames(summary(boot_test$percent))

Common_Name <- unique(boot_data$Common_Name)

year_name <- unique(boot_data$Year)

dimnames(boot_result)[[1]] <- as.character(unlist(Common_Name))

dimnames(boot_result)[[2]] <- as.character(unlist(conf_name))

dimnames(boot_result)[[3]] <- as.character(unlist(year_name))

boot_result <- as.data.frame(as.table(boot_result))

boot_result <- cast(boot_result, Var1 + Var3 ~ Var2, value = "Freq")

boot_result <- boot_result[c(1, 2, 6, 7)]

colnames(boot_result) <- c("Species", "Year", "Lower Bound", "Upper Bound")

colnames(mean_boot) <- unique(CPUE_subset$Year)

rownames(mean_boot) <- unique(CPUE_subset$Common_Name)

mean_boot <- melt(mean_boot)

colnames(mean_boot) <- c("Species", "Year", "Mean Difference")

mean_boot <- na.omit(mean_boot)

boot_result <- na.omit(boot_result)

boot_result <- merge(mean_boot, boot_result, by = c("Species", "Year"), all = TRUE)

boot_result$`Mean Difference` <- signif(boot_result$`Mean Difference`, 2)

boot_result$`Lower Bound` <- signif(boot_result$`Lower Bound`, 2)

boot_result$`Upper Bound` <- signif(boot_result$`Upper Bound`, 2)

boot_result$`Mean Difference (Lower Bound, Upper Bound)` <- paste(boot_result$`Mean Difference`, " (", boot_result$`Lower Bound`, ", ", boot_result$`Upper Bound`, ")", sep = "")

boot_result <- subset(boot_result, select = c("Species", "Year", "Mean Difference (Lower Bound, Upper Bound)"))
#===============================================================
#===============================================================
```

```{r echo = FALSE, warning = FALSE, message = FALSE}

#===============================================================
#===============================================================
# NMFS Analysis

# Load relevant Excel files

catch_data <- read.csv("NMFS_Data/ABL_2014_multi.csv", na.strings = "", header = TRUE)

catch_codes <- read.csv("NMFS_Data/Species_Catch_Codes.csv", na.strings = "", header = 
    TRUE)

names(catch_codes)[3:6] <- c("Polycorder_Number", "Species_Code", "Common_Name", "Scientific_Name")

catch_full <- read.csv("NMFS_Data/ABL_2014_full.csv", na.strings = "", header = TRUE)

names(catch_full)[c(6, 44, 45, 51)] <- c("Station_Number", "Species_Code", "Common_Name", "Ineffective_Hooks")

# Combine the multi dataset and catch codes to convert the polycorder numbers to species codes
# for Primary and Secondary catch

catch_data <- merge(catch_data, catch_codes, by.x = "Primary", by.y = 
    "Polycorder_Number", all.x = TRUE)

catch_data <- subset(catch_data, select = c("Station", "Species_Code", 
    "Secondary"))

colnames(catch_data)[colnames(catch_data) == "Species_Code"] <- "Primary"

catch_data <- merge(catch_data, catch_codes, by.x = "Secondary", by.y = 
    "Polycorder_Number", all.x = TRUE)

catch_data <- subset(catch_data, select = c("Station", "Primary", 
    "Species_Code"))

colnames(catch_data)[colnames(catch_data) == "Species_Code"] <- 
    "Secondary"

# Obtain unique list of species from the Primary and Secondary catch

speclist <- unique(c(catch_data$Primary, catch_data$Secondary))

# Extract all data for each species in the species list from the full dataset

species_data <- catch_full[(catch_full$Species_Code%in%speclist), 
    c("Station_Number", "Species_Code", "Common_Name", "Catch", "Hachi", 
    "Ineffective_Hooks")]

# Obtain the maximum number of Hachi from each station

station <- as.data.frame(with(species_data, tapply(Hachi, list(Station_Number), max)))

station$number <- as.numeric(rownames(station))

rownames(station)<-NULL

colnames(station) <- c("maxHachi", "Station")

# Obtain the total number of hooks from each station

station$tothks <- station$maxHachi*45

# Obtain the number of ineffective hooks from each station and add to station data

hachks <- as.data.frame(with(species_data, tapply(Ineffective_Hooks, list(Station_Number, Hachi), mean)))

ineffhks <- rowSums(hachks, na.rm = TRUE)

station <- cbind(station, ineffhks)

# Calculate the catch for each species at each station from the full dataset

spec_catch <- cast(species_data, Station_Number ~ Species_Code, sum, value = 
    "Catch")

# Combine the station and species catch data

catch_data2 <- merge(station, spec_catch, by.x = "Station", by.y = 
    "Station_Number")

# Reformat to a more usable form

catch_data3 <- melt(catch_data2, id = c("Station", "maxHachi", "tothks",
    "ineffhks"))

colnames(catch_data3) <- c("Station", "maxHachi", "tothks", "ineffhks", 
    "Species", "Catch")

# Calculate the primary catch for each species at each station for the multi dataset

pri_data <- count(catch_data, c("Station", "Primary"))

pri_data2 <- cast(pri_data, Station ~ Primary, sum, value = "freq")

pri_data3 <- melt(pri_data2, id = "Station")

colnames(pri_data3) <- c("Station", "Primary_Catch", "Species")

# Combine the calculated catches to get the full primary catch

catch_data4 <- join(catch_data3, pri_data3, type = "full")

catch_data4[is.na(catch_data4)] <- 0

catch_data4$priCatch <- rowSums(catch_data4[c("Catch", "Primary_Catch")])

# Calculate the primary CPUE

catch_data4$priCPUE <- catch_data4$priCatch / (catch_data4$tothks - 
   catch_data4$ineffhks)

# Calculate the secondary catch for each species at each station for the multi dataset

sec_data <- count(catch_data, c("Station", "Secondary"))

sec_data2 <- cast(sec_data, Station ~ Secondary, sum, value = "freq")

sec_data3 <- melt(sec_data2, id = "Station")

colnames(sec_data3) <- c("Station", "Secondary_Catch", "Species")

# Combine the calculated catches to get secondary catch (ommitting primary catch from multi dataset)

catch_data5 <- join(catch_data4, sec_data3, type = "full")

catch_data5[is.na(catch_data5)] <- 0

catch_data5$secCatch <- rowSums(catch_data5[c("Catch", "Secondary_Catch")])

catch_data5 <- catch_data5[order(catch_data5$Station),]

# Calculate the secondary CPUE

catch_data5$secCPUE <- catch_data5$secCatch / (catch_data5$tothks - 
    catch_data5$ineffhks)

# Remove species not found in species catch codes and any 0 catch values

catch_data5$Species[catch_data5$Species == "30051"] <- NA

catch_data5$Catch[catch_data5$Catch == 0] <- NA

catch_data5 <- na.omit(catch_data5)

catch_full <- rename(catch_full, replace = c("Species_Code" = "Species"))

# Obtain a list of the unique species from the full dataset

uniq_spec <- unique(catch_full$Species)

uniq_spec_frame <- data.frame(uniq_spec)

colnames(uniq_spec_frame)[colnames(uniq_spec_frame) == "uniq_spec"] <- "Species"

# Combine with full dataset for unique list of species common names matched to species codes

uniq_spec_name <- join(uniq_spec_frame, catch_full, by = "Species", type = "left", match = "first")

uniq_spec_name[c(2:44, 46:52)] <- list(NULL)

# Combine species name list with calculated data frame

catch_data6 <- merge(catch_data5, uniq_spec_name, by = "Species")

catch_data6 <- subset(catch_data6, select = c("Station", "priCPUE", "secCPUE", "Common_Name"))

catch_data6$Common_Name <- as.character(catch_data6$Common_Name)

catch_data6$Common_Name[catch_data6$Common_Name == "Aleutian/Bering/Alaska Skate Complex"
                      ] <- "Aleutian Bering Alaska Skate Complex"

# Prepare any objects for use inside the for-loop

Results2 <- NULL

Small2 <- NULL

Significant2 <- NULL

Sample2 <- NULL

mymeans3 <- NULL

mymeans4 <- NULL

CPUE_rank2 <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int3 <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int4 <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

catch_subset <- catch_data6

# Create scatterplots, QQ-plots, perform the Welch's T-Test on ranks, and
# create bootstrapped confidence intervals for each species
for(i in unique(catch_data6$Common_Name)){
  CPUE_spec <- catch_data6[catch_data6$Common_Name == i,]
  if(all(CPUE_spec$priCPUE == CPUE_spec$secCPUE)){
    catch_subset[catch_data6$Common_Name == i,] <- NA
    next
  }
  png(paste("NMFS_Data/Plots/", i,".png", sep = ""))
  plot(CPUE_spec$priCPUE, CPUE_spec$secCPUE, type = "p", xlab = 
         paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
         c(0, max(CPUE_spec$priCPUE) + .001), ylim = 
         c(0, max(CPUE_spec$secCPUE) + .001), main = 
         paste("Plot of", i))
  abline(a = 0, b = 1, lty = 3)
  dev.off()
  Sample2[i] <- nrow(CPUE_spec)
  if(nrow(CPUE_spec) == 1) {
    Small2[i] <- paste("Small Sample Size")
    next
  } else {
    mymean <- function(priCPUE, j) mean(priCPUE[j])
    myboot <- with(CPUE_spec, boot(priCPUE, mymean, R = 1000))
    if(sd(myboot$t) != 0){
      boot_conf <- boot.ci(myboot, type = "bca")
      conf_int3[i, ] <- boot_conf$bca
    }
    mymeans3[i] <- myboot$t0
    mymean2 <- function(secCPUE, j) mean(secCPUE[j])
    myboot2 <- with(CPUE_spec, boot(secCPUE, mymean2, R = 1000))
    if(sd(myboot2$t) != 0){
      boot_conf2 <- boot.ci(myboot2, type = "bca")
      conf_int4[i, ] <- boot_conf2$bca
    }
    mymeans4[i] <- myboot2$t0
    model <- lm(formula = secCPUE ~ priCPUE, data = CPUE_spec)
    png(paste("NMFS_Data/Plots/QQof",i,".png", sep = ""))
    layout(rbind(c(1,2), c(3,3)))
    qqnorm(CPUE_spec$priCPUE, ylim = c(-0.5,0.5), main = 
             "QQ-plot of Primary CPUE \n", i)
    qqline(CPUE_spec$priCPUE, lty = 3)
    qqnorm(CPUE_spec$secCPUE, ylim = c(-0.5,0.5), main = 
             "QQ-plot of Secondary CPUE \n", i)
    qqline(CPUE_spec$secCPUE, lty = 3)
    qqnorm(residuals(model), ylim = c(-0.5,0.5),
           main = "QQ-plot of Residuals obtained from \nSimple Regression",
           "Model \n", i)
    qqline(residuals(model), lty = 3)
    dev.off()
    if(sd(myboot$t) != 0 | sd(myboot2$t) != 0){
      CPUE_rank <- melt(CPUE_spec, id.vars = c("Station", "Common_Name"))
      colnames(CPUE_rank) <- c("Station", "Common_Name", "Type", "CPUE")
      CPUE_rank$CPUE <- with(CPUE_rank, rank(CPUE, ties.method = "average"))
      CPUE_rank <- cast(CPUE_rank, Station + Common_Name ~ Type, 
                        value = "CPUE")
      result <- with(CPUE_rank, t.test(priCPUE, secCPUE, var.equal = FALSE))
    if (result$p.value < 0.05) {
      Significant2[i] <- paste("Different Means")
    } else {
      Significant2[i] <- paste("Similar Means")}
      Results2[i] <- result$p.value
    }
  }
}

# Format all of the results into various dataframes for output into an Excel
# file

catch_subset <- catch_subset[complete.cases(catch_subset), ]

Results2 <- data.frame(Results2)

Significant2 <- data.frame(Significant2)

Small2 <- data.frame(Small2)

Sample2 <- data.frame(Sample2)

Means3 <- data.frame(mymeans3)

Means4 <- data.frame(mymeans4)

Significant_Results2 <- merge(Results2, Significant2, by = "row.names", all = TRUE)

Small_Sample2 <- merge(Small2, Sample2, by = "row.names", all = TRUE)

Results2 <- merge(Significant_Results2, Small_Sample2, by = "Row.names", all = TRUE)

if(nrow(Small2) > 0){
  colnames(Results2) <- c("Species", "p-value", "Significance", "Warning", "Sample Size")
} else {
  colnames(Results2) <- c("Species", "p-value", "Significance", "Sample Size")
}

Significant2 <- Significant_Results2[Significant_Results$Significant2 == "Different Means",]

if(nrow(Significant2) > 0) {colnames(Significant2) <- c("Species", "p-value", "Significant")
  Significant2 <- Significant2[, c("Species", "p-value")]}

colnames(conf_int3) <- c("Levels", "Unk", "Unk2", "Primary Lower CPUE", "Primary Upper CPUE")

colnames(conf_int4) <- c("Levels", "Unk", "Unk2", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int3 <- conf_int3[, c("Primary Lower CPUE", "Primary Upper CPUE")]

conf_int3 <- na.omit(conf_int3)

conf_int4 <- conf_int4[, c("Secondary Lower CPUE", "Secondary Upper CPUE")]

conf_int4 <- na.omit(conf_int4)

conf_int_all2 <- merge(conf_int3, conf_int4, by = "row.names", all = TRUE)

means_all2 <- merge(Means3, Means4, by = "row.names", all = TRUE)

colnames(means_all2) <- c("Species", "Primary Mean CPUE", "Secondary Mean CPUE")

colnames(conf_int_all2) <- c("Species", "Primary Lower CPUE", "Primary Upper CPUE", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int_all2 <- merge(conf_int_all2, means_all2, by = "Species", all = TRUE)

conf_int_all2$`Primary Mean CPUE` <- round(conf_int_all2$`Primary Mean CPUE`, 4)

conf_int_all2$`Primary Lower CPUE` <- round(conf_int_all2$`Primary Lower CPUE`, 4)

conf_int_all2$`Primary Upper CPUE` <- round(conf_int_all2$`Primary Upper CPUE`, 4)

conf_int_all2$`Secondary Mean CPUE` <- round(conf_int_all2$`Secondary Mean CPUE`, 4)

conf_int_all2$`Secondary Lower CPUE` <- round(conf_int_all2$`Secondary Lower CPUE`, 4)

conf_int_all2$`Secondary Upper CPUE` <- round(conf_int_all2$`Secondary Upper CPUE`, 4)

conf_int_all2$`Primary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all2$`Primary Mean CPUE`, " (", conf_int_all2$`Primary Lower CPUE`, ", ", conf_int_all2$`Primary Upper CPUE`, ")", sep = "")

conf_int_all2$`Secondary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all2$`Secondary Mean CPUE`, " (", conf_int_all2$`Secondary Lower CPUE`, ", ", conf_int_all2$`Secondary Upper CPUE`, ")", sep = "")

conf_int_all2 <- conf_int_all2[, c("Species", "Primary Mean CPUE (Lower Bound, Upper Bound)", "Secondary Mean CPUE (Lower Bound, Upper Bound)")]

# Calculate the bootstrapped difference-of-means confidence intervals for
# each species

boot_data2 <- melt(catch_subset, id.vars = c("Station", "Common_Name"))

colnames(boot_data2) <- c("Station", "Common_Name", "Type", "CPUE")

diff.means <- function(d, f)
{    n <- nrow(d)
tp1 <- 1:table(as.numeric(d$Type))[1]
m1 <- sum(d[tp1, 4] * f[tp1])/sum(f[tp1])
m2 <- sum(d[-tp1, 4] * f[-tp1])/sum(f[-tp1])
ss1 <- sum(d[tp1, 4]^2 * f[tp1]) - (m1 * m1 * sum(f[tp1]))
ss2 <- sum(d[-tp1, 4]^2 * f[-tp1]) - (m2 * m2 * sum(f[-tp1]))
c(m1 - m2, (ss1 + ss2)/(sum(f) - 2))
}

boot_result2 <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

diff_mean_results2 <- NULL

for(i in unique(boot_data2$Common_Name)){
  boot_spec <- subset(boot_data2, boot_data2$Common_Name == i)
  if (nrow(boot_spec) < 3) {next}
  type_boot <- boot(boot_spec, diff.means, R = 1000, strata = boot_spec[ ,4])
  if(sd(type_boot$t[, 1]) != 0 & sd(type_boot$t[, 2]) != 0){
    boot_test <- boot.ci(type_boot, type = "perc")
    boot_result2[i, ] <- boot_test$perc
  }
  diff_mean_results2[i] <- type_boot$t0[1]
}

# Format these results as a dataframe for output to Excel

boot_result2 <- boot_result2[, c("V4", "V5")]

diff_mean_results2 <- data.frame(diff_mean_results2)

boot_result2 <- na.omit(boot_result2)

boot_result2 <- merge(diff_mean_results2, boot_result2, by = "row.names", all = TRUE)

colnames(boot_result2) <- c("Species", "Mean Difference", "Lower Bound", "Upper Bound")

boot_result2$`Mean Difference` <- signif(boot_result2$`Mean Difference`, 2)

boot_result2$`Lower Bound` <- signif(boot_result2$`Lower Bound`, 2)

boot_result2$`Upper Bound` <- signif(boot_result2$`Upper Bound`, 2)

boot_result2$`Mean Difference (Lower Bound, Upper Bound)` <- paste(boot_result2$`Mean Difference`, " (", boot_result2$`Lower Bound`, ", ", boot_result2$`Upper Bound`, ")", sep = "")

boot_result2 <- subset(boot_result2, select = c("Species", "Mean Difference (Lower Bound, Upper Bound)"))
#===============================================================
#===============================================================
```
Auke Bay Laboratories

Alaska Fisheries Science Center

National Marine Fisheries Service

National Oceanic and Atmospheric Administration

17109 Point Lena Loop Road

Juneau, AK, 99801

Keywords: catch-per-unit-effort, CPUE, longlining, bootstrapping, t test, Welch's test

#ABSTRACT

The catch per unit of effort (CPUE) is a common metric used in stock assessments. In it’s simplest form it is a unit of caught fish divided by a unit of effort. In the case of longline fishing, in which a length of groundline has a number of hooks spaced along the line, the CPUE is often the number of fish per effective hook. In calculating the CPUE, assumptions are made about hook competition, gear placement, predation, etc. In this study we use longline survey data from two fishery-independent surveys operating in the eastern North Pacific Ocean to examine one potential impact of predation. These surveys are used to inform stock assessments and each survey only reports one fish when instances of more than one fish are caught on a single hook. However, one survey records the first caught fish, while the other records the second caught fish. The purpose of this study was to examine if hooking order can impact estimates of CPUE. Two CPUE indices were calculated for each species occurring in multiple fish per hook situations: 1) based on only the first hooked fish; and 2) based only on the second hooked fish. Unequal variances T Tests on ranks, bootstrapped confidence intervals, and difference of means bootstrapped confidence intervals were used for comparing the two CPUEs. The tests largely coincided with each other, despite the small sample size in a number of the species and years. The only significant results across all 3 tests was for the octopus in the NMFS survey (n = `r Results2[Results2$Species == "Octopus",]["Sample Size"]`, p-value = `r round(Results2[Results2$Species == "Octopus",]["p-value"], 4)`) and the 2007, 2009, and 2010 octopus in the IPHC survey (n = `r Results[Results$Species == "Octopus" & Results$Year == 2007,]["Sample Size"]`, `r Results[Results$Species == "Octopus" & Results$Year == 2009,]["Sample Size"]`, and `r Results[Results$Species == "Octopus" & Results$Year == 2010,]["Sample Size"]`, p-value = `r round(Results[Results$Species == "Octopus" & Results$Year == 2007,]["p-value"], 4)`, `r round(Results[Results$Species == "Octopus" & Results$Year == 2009,]["p-value"], 4)`, and `r round(Results[Results$Species == "Octopus" & Results$Year == 2010,]["p-value"], 4)`; respectively). In general, it was found that there is no significant effect on CPUE depending on which fish is reported.

##INTRODUCTION

Fish stock assessments are based on fishery-dependent and -independent data sources, and assume that those data sources are accurate and precise (or if not, uncertainty is included). Metrics of catch, either absolute, such as total catch, or relative, such as catch-per-unit-effort (CPUE), are generally the basis for most stock assessment models. The CPUE is entirely dependent on the data reporting and estimation methods and varies greatly between gear types, fisheries, and standardizations. Thus, for stock assessments, it is critical to have an understanding of the data source and how CPUE is estimated.

There are two primary fishery-independent longline surveys operating in the Gulf of Alaska and the Bering Sea/Aleutian Islands Fishery Management Plan Areas which inform groundfish stock assessments: the International Pacific Halibut Commission (IPHC) annual halibut setline survey; and the National Marine Fisheries Service (NMFS) annual groundfish longline survey. Both surveys provide CPUE estimates of all species caught, however the data recording methods differ. 

The IPHC survey operates along the extent of the United States and Canadian west coasts and north through Alaskan waters (Goen et al. 2018). The number of stations varies slightly from year to year, and the survey has been expanding in recent years. In 2017, 1,493 stations were successfully completed. The IPHC survey samples areas of halibut habitat, and thus the stations are located in waters shallower than 500 m (i.e., continental shelf), and sometimes are near shore. Most stations consist of 5-6 skates of gear, each skate consisting of 100 16/0 baited with chum salmon and spaced 5.5 m apart. For the purposes of estimating CPUE, the relevant data recorded is the number of fish caught, the total number of hooks, the number of observed hooks and the number of observed ineffective hooks. A complete census of hooks is recorded at stations within Canadian waters, while a subsample (the first 20 hooks on each skate) is recorded at stations within U.S. waters. This 20% subsampling is sufficient to accurately extrapolate total catch for most species caught during the survey (Menon et al. 2004).

In contrast, the NMFS survey was designed to sample the slope habitat, which spans from shallow to deep (Sigler and Lunsford XX). This survey fishes 87 stations each year, with most stations ranging from 150 – 1000 m throughout the set. Each station consists of 80 skates of gear, each 100 m with 45 13/0 hooks spaced 2 m apart and baited with squid. This survey records a complete census of all hooks brought onboard, thus no extrapolation from observed catch to total catch is required. The CPUE can simply be calculated as the number caught over the number of effective hooks.

While estimating a CPUE in this manner can be quite straight forward, there are caveats. One such problem is when more than one fish occur on a single hook. This is usually the result of a predation event. A predation event can have three outcomes: 1) prey is hooked, predator attempts to or partially eats prey and is also hooked; 2) prey is hooked, predator completely eats prey and is also hooked; and 3) prey is hooked, predator eats prey but does not get hooked. Case 2 and 3 result in either only the predator on the hook or no hooked fish at all, and because it is impractical to examine the gut contents of every fish caught, observing and recording instances of Case 2 are rare (also assuming no regurgitation). Thus, Case 2 and 3 are unobservable and assumed unknown. Case 1 is observable and data do exist to examine the impact on CPUE estimates. 

Predation such as this has not previously been examined in longline survey data. The NMFS survey records only the prey (i.e., first fish hooked) and ignores any other animals on the hook even though it is usually still retained by the vessel and is thus a removal. The IPHC survey records the predator (the last animal hooked, even in cases with more than one predator) and ignores the prey animal. This case essentially treats the prey animal’s removal as a natural mortality event. The purpose of this project was to examine data from each survey to determine if the method of recording hooked animals (i.e., first or second on the hook) causes a significant change in the overall annual estimate of CPUE that might be used in stock assessments.

##METHODS

Data from each survey were provided for this analysis. The NMFS survey does not record instances when more than one fish per hook occur, thus a special project was conducted during the 2014 survey to record any instances when a second fish was caught on a single hook. These data were available summarized by station. The IPHC survey has a complete census of hooks and records any instances of multiple fish per hook at all stations occurring in Canadian waters. The IPHC was able to provide the full census data for the years 2004 – 2014.

Due to the shallower depth of the stations on the IPHC survey, the catch is more diverse, `r length(unique(CPUE_data$Common_Name))` observed species and `r length(unique(CPUE_subset$Common_Name))` species with a different CPUE~s~ than CPUE~p~, compared to the NMFS survey reporting `r length(unique(catch_data6$Common_Name))` observed species and `r length(unique(catch_subset$Common_Name))` species with a different CPUE~s~ than CPUE~p~. Some species categories were uninformative for the purpose of this study, so they were combined with other categories. For example, the “Benthic Invertebrates” category is a combination of species ranging from Sea Cucumbers to Sea Pens.

The CPUE metric used in this project was calculated as the amount of catch divided by the total hooks minus the ineffective hooks. The amount of catch is all recorded catch of that species on surveyed hooks, total hooks is the number of hooks retrieved, and ineffective hooks are hooks that are bent, broken, missing, etc. The data were divided into two categories: Primary hooked fish and Secondary hooked fish. The CPUE~p~ is the CPUE calculated based on the first fish on a hook and the CPUE~s~ is based on the second fish on a hook. All other instances (only one fish on a hook) exist as normal in both categories. All analyses were conducted in R [@R2017].

The CPUEs calculated for each station were then used to calculate a mean CPUE for each species caught for each year. The number of stations with a CPUE for any given species is the sample size referred to in *Table 1* and *Table 4*. An unequal variances T Test (Welch's Test) on the ranks of the mean CPUEs for the comparison of the mean CPUE~p~ CPUE~s~. The unequal variances T Test performed on ranks has been shown to be robust against unequal variances and non-normally distributed data [@Ruxton2006; @Zimmerman1993]. All tests were performed at $\alpha$ = 0.05. To qualitatively determine bivariate normality, QQ-plots were constructed of each variable (CPUE~p~ and CPUE~s~) as well as the residuals of a linear model of the two variables to provide a visual indicator of normality. If final test results were not significant the CPUE's were considered to have similar means, thus the catch recorded on the hook (first or second) did not affect the CPUE. This test was conducted across each species caught by the longline surveys. Scatterplots were also constructed of each species, plotting CPUE~s~ against CPUE~p~ with a linear reference line, a subset of these are shown in *Figure 1* and *Figure 2*. Bootstrapping was conducted for each species to calculate confidence intervals about the mean CPUE. For the bootstrapping procedure, we created 1000 replicates for each species, CPUE~p~, and CPUE~s~ and the adjusted bootstrap percentile (BCa) confidence intervals were used on this bootstrapped dataset to adjust for any bias that may exist in the data [@Efron1986]. Bootstrapped 2.5th and 97.5th confidence intervals for the difference of means between the two CPUE’s were also calculated.

##RESULTS

The results of the unequal variances T Tests for the IPHC survey are shown in *Table 1*. The bootstrapping methods for the IPHC survey are presented in *Table 2* (BCa method) and *Table 3* (difference of means). *Table 1* reveals that nearly none of the unequal variances T Tests possess a p-value less than 0.05, with the exception of the 2007, 2009, and 2010 octopus. As shown in *Table 2*, the BCa confidence intervals overlap across most of the interval between the CPUE~p~ and CPUE~s~, possessing similar lower and upper bounds and means. *Table 3* shows that the difference of means confidence intervals are largely centered on 0, though a greater number of species and years appear to be affected by thw fish recorded on the hook than in the previous tables.  In *Figure 1*, the plots of certain species are presented to represent four of the species apparently most affected by which fish is recorded on the hook: Octopus, Thornyhead, Darkblotched Rockfish, and Sixgill Shark.

The results of the unequal variances T Tests for the NMFS survey are shown in *Table 4*. The bootstrapping methods for the NMFS survey are presented in *Table 5* (BCa method) and *Table 6* (difference of means). It is evident in these tables that most of the species are not affected by which fish on the hook is recorded. The Octopus is the only species with significant results across all three tests (n = `r Results2[Results2$Species == "Octopus",]["Sample Size"]`, p-value = `r round(Results2[Results2$Species == "Octopus",]["p-value"], 4)`). The BCa confidence intervals for the Octopus do not overlap and the 2.5th and 97.5th confidence intervals do not contain zero. Also, the Commander Skate, Greenland Turbot, Lingcod, Longnose Skate, Octopus, Pacific Cod, Sablefish, Shortspine Thornyhead, Whiteblotched Skate, and Yelloweye Rockfish 2.5th and 97.5th confidence intervals do not contain zero, though the other tests do not indicate significance. As with the IPHC survey, *Figure 2* demonstrates four of the species apparently most affected by which fish is recorded on the hook: Octopus, Thornyhead, Lingcod, and Pacific Cod.

##DISCUSSION

Both surveys across all tests conducted revealed that the Octopus was the only species susceptible to differences in CPUE~p~ and CPUE~s~ based on which hook was counted in the study. However, given that the overall catch of Octopus was relatively low (IPHC CPUE~p~ = `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2007, ]["Primary_CPUE"]), 4)`, `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2009, ]["Primary_CPUE"]), 4)`, and `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2010, ]["Primary_CPUE"]), 4)`; IPHC CPUE~s~ = `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2007, ]["Secondary_CPUE"]), 4)`, `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2009, ]["Secondary_CPUE"]), 4)`, and `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2010, ]["Secondary_CPUE"]), 4)`; Number of IPHC Stations = `r Results[Results$Species == "Octopus" & Results$Year == 2007, ]["Sample Size"]`, `r Results[Results$Species == "Octopus" & Results$Year == 2009, ]["Sample Size"]`, and `r Results[Results$Species == "Octopus" & Results$Year == 2010, ]["Sample Size"]`; IPHC Years = 2007, 2009, and 2010, respectively; NMFS CPUE~p~ = `r round(colMeans(catch_subset[catch_subset$Common_Name == "Octopus", ]["priCPUE"]), 4)`; NMFS CPUE~s~ = `r round(colMeans(catch_subset[catch_subset$Common_Name == "Octopus", ]["secCPUE"]), 4)`; Number of NMFS Stations = `r Results2[Results2$Species == "Octopus", ]["Sample Size"]`) and the species is not being targeted by the fisheries, this likely has little overall impact on the population. This indicates that there is no concerning affect on CPUE depending on which fish is recorded on a hook.

The results shown for the IPHC survey of the unequal variances T Test indicate that there is no statistical difference between the Primary and Secondary CPUE's. The results of the unequal variances T Test are supported by the overlapping BCa confidence intervals. This is again supported by the difference of means bootstrapped percentile confidence intervals most of which contain 0 in the interval. The tests do show that the Octopus was affected by which fish on a hook was counted, particularly the 2007, 2009, and 2010 Octopus, as shown in *table 1*. There is an increasing number of species and years with significant results in each consecutive table from 1-3. Each species and year with a p-value < 0.05 in *Table 1* has nonoverlapping BCa confidence intervals in *Table 2*, with a few additional species and years in *Table 2*. Each species and year with nonoverlapping BCa confidence intervals in *Table 2* have 2.5th and 97.5th confidence intervals that do not contain 0 in *Table 3*, again with a few additional species and years. This likely indicates that each consectutive test is simply more sensitive to changes in CPUE~p~ and CPUE~s~ than the previous test. Most of the tested species were not shown to be significantly affected by the fish counted on the hook in the event that multiple fish were on the same hook. Upon visual analysis of the scatterplots, the same conclusion can be drawn, since the plots showed that the CPUE~p~ and CPUE~s~ were identical most of the time and any deviations were unsubstantial. This is evident in *Figure 1* when observing the Octopus, which deviates from the reference line, but only slightly.

The NMFS survey results were very similar to the IPHC survey results. The Octopus had a p-value < 0.05, nonoverlapping BCa confidence intervals, and a 2.5th and 97.5th confidence interval that did not contain 0. The results of shown in *Table 4* and *Table 5* are identical, showing only significant results for the Octopus. The other species that had a 2.5th and 97.5th confidence interval that did not contain 0 are not considered significant given the results of the other two tests and the indication in the IPHC survey that this is the most sensitive of the three tests. The deviation for the Octopus between the CPUE~p~ and CPUE~s~ can be clearly seen in *Figure 2*.

It is unclear what the results for the Octopus indicate at this time, though the results of the IPHC survey show a greater CPUE~p~ (`r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2007,]["Primary_CPUE"]), 4)`, `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2009,]["Primary_CPUE"]), 4)`, and `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2010,]["Primary_CPUE"]), 4)`) than CPUE~s~ (`r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2007,]["Secondary_CPUE"]), 4)`, `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2009,]["Secondary_CPUE"]), 4)`, and `r round(colMeans(CPUE_subset[CPUE_subset$Common_Name == "Octopus" & CPUE_subset$Year == 2010,]["Secondary_CPUE"]), 4)`), while the results of the NMFS survey show a greater CPUE~s~ (`r round(colMeans(catch_subset[catch_subset$Common_Name == "Octopus",]["secCPUE"]), 4)`) than CPUE~p~ (`r round(colMeans(catch_subset[catch_subset$Common_Name == "Octopus",]["priCPUE"]), 4)`). A possible reasoning for why most species show no dependence on which fish is recorded is that the occurrence of two fish on the same hook is relatively rare. Of the `r format(hook_total, big.mark = ",", trim = TRUE)` hooks analyzed in this study, only `r round(all_percent, 3)`% of hooks had secondary catch, and of the hooks that had primary catch (excluding inanimate objects and unidentified organic matter), only `r round(catch_percent, 3)`% had secondary catch.

###ACKNOWLEDGEMENTS

###CITATIONS
<br>

<div id="refs" class="references"></div>

###APPENDIX
<br>
```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}
#===============================================================
#===============================================================
library(knitr, quietly = TRUE)

# Change the first NA value in each column for defining later

Results$Significance <- as.character(Results$Significance)

Results$Warning <- as.character(Results$Warning)

Results$Warning[match(NA, Results$Warning)] <- "-*"

# Set all other NA values to '-' and create table of results

options(knitr.kable.NA = '-')

kable(Results, caption = "Table 1 --  IPHC. All of the species analyzed in the study by year, presenting the p-value for the test performed, the significance of that test, the test used, a warning column to indicate inadequate samples, and the sample size for that species where sample size is the number of stations with that species/year combination.", digits = 3, row.names = FALSE, format.args = list(na.encode = TRUE))
```

######*No warning, sample size is greater than 1

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of the BCa confidence intervals

kable(conf_int_all, caption = "Table 2 --  IPHC. Bootstrapped 95% bias-corrected confidence intervals for each species by year on the Primary and Secondary CPUE.  Means are included to see the direction of bias in the samples.", digits = 4, row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of difference-of-means confidence intervals

boot_result <- na.omit(boot_result)

kable(boot_result, caption = "Table 3 --  IPHC. Bootstrapped 95% percentile confidence intervals of the difference of means between the Primary and Secondary CPUE for each species by year.  The means are included.", row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 1 --  IPHC. Scatterplots of Octopus, Thornyhead, Darkblotched Rockfish, and Sixgill Shark from every year in which Secondary CPUE varied from Primary CPUE, with a reference line [slope = 1, intercept = 0]. Note the substantial variation in many of the Octopus plots, and the more minor variation in the other species. These species were chosen as the most variable cases.", fig.height = 6.5, fig.width = 6.5}

# Store data for representative species and year

plot_data <- CPUE_subset[CPUE_subset$Common_Name %in% c("Thornyhead", "Octopus", "Darkblotched Rkfish", "Sixgill Shark"),]

plot_data$Common_Name_Order <- factor(plot_data$Common_Name, levels = c("Octopus", "Thornyhead", "Sixgill Shark", "Darkblotched Rkfish"))

plot_image <- ggplot(plot_data, aes(Primary_CPUE, Secondary_CPUE)) + geom_point() + geom_abline(slope = 1, intercept = 0) + labs(x = "Primary CPUE", y = "Secondary CPUE")

plot_image + facet_wrap( ~ Common_Name_Order + Year, ncol = 3, dir = "v")
#===============================================================
#===============================================================
```

####



```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}
#===============================================================
#===============================================================
# Create a table of the results

kable(Results2, caption = "Table 4 --  NMFS. All of the species analyzed in the study, presenting the p-value for the test performed, the significance of that test, the test used, a warning column to indicate inadequate samples, and the sample size for that species.", digits = 3, row.names = FALSE, format.args = list(na.encode = TRUE))
```

######*Not calculated due to inadequate sample size  
**No warning, sample size is greater than 1

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of the BCa confidence intervals

kable(conf_int_all2, caption = "Table 5 --  NMFS. Bootstrapped 95% bias-corrected confidence intervals for each species on the Primary and Secondary CPUE. Means are included to see the direction of bias in the samples.", digits = 4, row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of difference-of-means confidence intervals

kable(boot_result2, caption = "Table 6 --  NMFS. Bootstrapped 95% percentile confidence intervals of the difference of means between the Primary and Secondary CPUE. The means are included.", row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 2 --  NMFS. Scatterplots of Pacific Cod, Lingcod, Octopus, and Shortspine Thornyhead with a reference line [slope = 1, intercept = 0]. Note that there is little variation from the reference line in any of the plots. These species were chosen as some of the most variable species in the dataset.", fig.height = 6.5, fig.width = 6.5}

# Store data for representative species and year

plot_data2 <- catch_data6[catch_data6$Common_Name %in% c("Shortspine thornyhead", "Octopus", "Lingcod", "Pacific cod"),]

plot_data2$Common_Name_Order <- factor(plot_data2$Common_Name, levels = c("Octopus", "Shortspine thornyhead", "Lingcod", "Pacific cod"))

plot_image2 <- ggplot(plot_data2, aes(priCPUE, secCPUE)) + geom_point() + geom_abline(slope = 1, intercept = 0) + labs(x = "Primary CPUE", y = "Secondary CPUE")

plot_image2 + facet_wrap( ~ Common_Name_Order, ncol = 2, dir = "h")
#===============================================================
#===============================================================
```
