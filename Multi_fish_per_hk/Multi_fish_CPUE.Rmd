
---
title: "CPUE Analysis"
author: "Danny Cooper"
csl: Format/ecology.csl
output:
  word_document:
    fig_caption: yes
    reference_docx: markdown_reference.docx
    toc: yes
bibliography: Format/library.bib
---

```{r echo = FALSE, warning = FALSE, message = FALSE, results = "hide"}
#===============================================================
#===============================================================
# Danny Cooper
# IPHC Data Analysis

# Install/load necessary packages

libs<-c("plyr","reshape","rmarkdown","knitr","boot")
if(length(libs[which(libs %in% rownames(installed.packages()) == FALSE )])>0){
  install.packages(libs[which(libs %in% rownames(installed.packages()) == FALSE )])
  }
lapply(libs,library,character.only=T)

# Import relevant files (hook census and hook data files)

catch_data <- read.csv("IPHC_Data/IPHC_hook_census.csv", na.strings = "", header = TRUE)

colnames(catch_data)[8] <- "cmnnme_1"

station_data <- read.csv("IPHC_Data/Hook_Data2.csv", na.strings = "", header = TRUE)

# Reformat the values of the second species number to 0's

catch_data$secspcno[catch_data$secspcno == "NULL"] <- NA

catch_data$secspcno <- as.numeric(catch_data$secspcno)

catch_data$secspcno[is.na(catch_data$secspcno)] <- 0

# Calculate the percent of secondary catch relative to primary catch and 
# number of hooks

catch_amount <- catch_data[catch_data$cmnnme != "Inanimate Object" & 
    catch_data$cmnnme != "Missing Hook/Gangion" & catch_data$cmnnme != 
    "Hook with Skin" & catch_data$cmnnme != "Hook with Bait" & catch_data$cmnnme 
    != "Empty Hook" & catch_data$cmnnme != "Bent Hook" & catch_data$cmnnme != 
    "Bent/Broken/Missing" & catch_data$cmnnme != "unident. organic matter",]

catch_percent <- (nrow(catch_amount[catch_amount$secspcno != 0, ]) / 
    nrow(catch_amount)) * 100 #gives the % of hooks with catch that had more than one fish

all_percent <- (nrow(catch_data[catch_data$secspcno != 0, ]) / 
    nrow(catch_data)) * 100 #gives the % of all hooks with more than one fish/item

sec_percent <- cbind(all_percent, catch_percent)

colnames(sec_percent) <- c("multi_All_Hooks", "multi_catch_Hooks") 

# Subset the hook data file to contain only desired columns and rename them

hook_data <- subset(station_data, select = c("yr", "station", "hksretriev", "hksobs", "ineffhks"))

colnames(hook_data) <- c("Year", "Station", "hksretriev", "hksobs", "ineffhks")

# Insert new column into the hook data for the total number of ineffective 
# hooks

hook_data$totineffhks <- hook_data$ineffhks / hook_data$hksobs * hook_data$hksretriev

# Split the dates into separate columns to create a column for the year

catch_data$yr <- lapply(strsplit(as.character(catch_data$Date), "\\/"), "[", 3)

catch_data$yr <- as.numeric(catch_data$yr)

# Insert a catch row to be summed for each species later

catch_data$Catch <- rep(1, nrow(catch_data))

# Insert the primary catch data into any row containing a 0 in secondary 
# catch and do the same for the common name

catch_data$secspcno <- ifelse(catch_data$secspcno == 0, catch_data$prispcno, 
    catch_data$secspcno)

catch_data$cmnnme <- as.character(catch_data$cmnnme)

catch_data$cmnnme_1 <- as.character(catch_data$cmnnme_1)

catch_data[catch_data$cmnnme_1 == "NULL", "cmnnme_1"]  <- catch_data[catch_data$cmnnme_1 == "NULL", "cmnnme"]

# Select the relevant data from this new dataset to divide the primary and
# secondary catches and sum each of the columns to calculate the catch for 
# each species by station and year

pri_data <- subset(catch_data, select = c("Station", "yr", "cmnnme", "Catch"))

pri_catch <- ddply(pri_data, c("Station", "yr", "cmnnme"), 
    numcolwise(sum))

sec_data <- subset(catch_data, select = c("Station", "yr", "cmnnme_1", 
    "Catch"))

sec_catch <- ddply(sec_data, c("Station", "yr", "cmnnme_1"), 
    numcolwise(sum))

# Combine these datasets to give the primary and secondary catch for each
# species by station and year; set any remaining missing values to 0; rename
# each column

catch_all <- merge(pri_catch, sec_catch, by.x = c("Station", "yr", "cmnnme"),
    by.y = c("Station", "yr", "cmnnme_1"), all = TRUE)

catch_all[is.na(catch_all)] <- 0

colnames(catch_all) <- c("Station", "Year", "Common_Name", "Primary_Catch", 
    "Secondary_Catch")

# Combine this dataset with the hook data by station and year to provide
# the catch and number of ineffective hooks for each station and year

catch_hook <- merge(catch_all, hook_data, by = c("Station", "Year"), 
    all.x = T) 

# Extrapolate the amount of catch to the entire line of hooks and calculate
# the CPUE

catch_hook$Est_Primary_Catch <- catch_hook$hksretriev / catch_hook$hksobs * catch_hook$Primary_Catch

catch_hook$Est_Secondary_Catch <- catch_hook$hksretriev / catch_hook$hksobs * catch_hook$Secondary_Catch

catch_hook$Primary_CPUE <- catch_hook$Est_Primary_Catch / (catch_hook$hksretriev - catch_hook$totineffhks)

catch_hook$Secondary_CPUE <- catch_hook$Est_Secondary_Catch / (catch_hook$hksretriev - catch_hook$totineffhks)

# Select the desired data from this dataset (CPUE, station, year, and species)

CPUE_data <- catch_hook[, c("Station", "Year", "Common_Name", "Primary_CPUE", "Secondary_CPUE")] 

# Remove NA's and NULL values from the dataset

CPUE_data <- CPUE_data[complete.cases(CPUE_data), ]

# Remove categories not of interest and combine other categories together

CPUE_data <- subset(CPUE_data, CPUE_data[, 3] != "Inanimate Object" & CPUE_data[, 3] != "Missing Hook/Gangion" & CPUE_data[, 3] != "Hook with Skin" & CPUE_data[, 3] != "Hook with Bait" & CPUE_data[, 3] != "Empty Hook" & CPUE_data[, 3] != "Bent Hook" & CPUE_data[, 3] != "Bent/Broken/Missing" & CPUE_data[, 3] != "unident. organic matter" & CPUE_data[, 3] != "Unknown/Unspecified")

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. thornyhead (Idiot)"] <- "Thornyhead"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Shortspine Thornyhead"] <- "Thornyhead"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sunflower Sea Star"] <- "Starfish"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Starfish"] <- "Starfish"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Coral"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Sponge"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Anemone"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Gastropod"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Red Tree Coral"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Barnacles"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Cucumber"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "unident. Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Brown King Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Tanner Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Box Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Red King Crab"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Whip"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Sea Urchin"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Shells"] <- "Benthic Invertebrates"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Rougheye/Shortraker"] <- "Rougheye Shortraker"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Greenland/Kamchatka/Arrowtooth"] <- "Greenland Kamchatka Arrowtooth"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Kamchatka/Arrowtooth"] <- "Kamchatka Arrowtooth"

CPUE_data$Common_Name[CPUE_data$Common_Name == "Bering/Alaska Skate"] <- "Bering Alaska Skate"

# Prepare any objects for use inside the for-loop

unq_key <- unique(CPUE_data[,c("Year", "Common_Name")])

Y <- length(unique(unq_key$Year))

I <- length(unique(unq_key$Common_Name))

Results <- matrix(ncol = Y, nrow = I)

Small <- matrix(ncol = Y, nrow = I)

Significant <- matrix(ncol = Y, nrow = I)

Sample <- matrix(ncol = Y, nrow = I)

Test <- matrix(ncol = Y, nrow = I)

mymeans <- matrix(ncol = Y, nrow = I)

mymeans2 <- matrix(ncol = Y, nrow = I)

CPUE_rank <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int <- array(dim = c(I,5,Y))

conf_int2 <- array(dim = c(I,5,Y))

# Create scatterplots, QQ-plots, perform the Welch's T-Test on ranks, and
# create bootstrapped confidence intervals for each species

for(i in 1:nrow(unq_key)){
  spec <- unq_key[i, 2]
  year <- unq_key[i, 1]
  row <- match(spec, unique(unq_key$Common_Name))
  col <- match(year, unique(unq_key$Year))
  CPUE_spec <- CPUE_data[CPUE_data$Year == year & CPUE_data$Common_Name == spec,]
  png(paste("IPHC_Data/Plots/", spec, year,".png", sep = ""))
    plot(CPUE_spec$Primary_CPUE, CPUE_spec$Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(CPUE_spec$Primary_CPUE) + .001), ylim = 
        c(0, max(CPUE_spec$Secondary_CPUE) + .001), main = 
        paste("Plot of", spec,year))
    abline(a = 0, b = 1, lty = 3)
    dev.off()
    Sample[row, col] <- nrow(CPUE_spec)
    if(nrow(CPUE_spec) == 1) {
    Small[row, col] <- paste("Small Sample Size")
    next
    } else {
    mymean <- function(Primary_CPUE, j) mean(Primary_CPUE[j])
    myboot <- with(CPUE_spec, boot(Primary_CPUE, mymean, R = 1000))
    if(sd(myboot$t) != 0){
    boot_conf <- boot.ci(myboot, type = "bca")
    conf_int[row, ,col] <- boot_conf$bca
    }
    mymeans[row, col] <- myboot$t0
    mymean2 <- function(Secondary_CPUE, j) mean(Secondary_CPUE[j])
    myboot2 <- with(CPUE_spec, boot(Secondary_CPUE, mymean2, R = 1000))
    if(sd(myboot2$t) != 0){
    boot_conf2 <- boot.ci(myboot2, type = "bca")
    conf_int2[row, ,col] <- boot_conf2$bca
    }
    mymeans2[row, col] <- myboot2$t0
    model <- lm(formula = Secondary_CPUE ~ Primary_CPUE, data = CPUE_spec)
    jpeg(paste("IPHC_Data/Plots/QQof",spec,year,".jpg", sep = ""))
    layout(rbind(c(1,2), c(3,3)))
    qqnorm(CPUE_spec$Primary_CPUE, ylim = c(-0.5,0.5), main = 
        "QQ-plot of Primary CPUE \n", row, col)
    qqline(CPUE_spec$Primary_CPUE, lty = 3)
    qqnorm(CPUE_spec$Secondary_CPUE, ylim = c(-0.5,0.5), main = 
        "QQ-plot of Secondary CPUE \n", row, col)
    qqline(CPUE_spec$Secondary_CPUE, lty = 3)
    qqnorm(residuals(model), ylim = c(-0.5,0.5),
        main = "QQ-plot of Residuals obtained from \nSimple Regression",
        "Model \n", row, col)
    qqline(residuals(model), lty = 3)
    dev.off()
    if(sd(myboot$t) != 0 | sd(myboot2$t) != 0){
    CPUE_rank <- melt(CPUE_spec, id.vars = c("Station", "Year", 
        "Common_Name"))
    colnames(CPUE_rank) <- c("Station", "Year", "Common_Name", "Type", "CPUE")
    CPUE_rank$CPUE <- with(CPUE_rank, rank(CPUE, ties.method = "average"))
    CPUE_rank <- cast(CPUE_rank, Station + Year + Common_Name ~ Type, 
        value = "CPUE")
    result <- with(CPUE_rank, t.test(Primary_CPUE, Secondary_CPUE, var.equal =
    FALSE))
    if (result$p.value < 0.05) {
    Significant[row, col] <- paste("Different Means")
        } else {
        Significant[row, col] <- paste("Similar Means")}
    Results[row, col] <- result$p.value
    }
}}

# Format all of the results into various dataframes for output into an Word
# table

colnames(Results) <- unique(unq_key$Year)

rownames(Results) <- unique(unq_key$Common_Name)

Results <- melt(Results)

colnames(Results) <- c("Species", "Year", "p-value")

colnames(Small) <- unique(unq_key$Year)

rownames(Small) <- unique(unq_key$Common_Name)

Small <- melt(Small)

colnames(Small) <- c("Species", "Year", "Warning")

colnames(Sample) <- unique(unq_key$Year)

rownames(Sample) <- unique(unq_key$Common_Name)

Sample <- melt(Sample)

colnames(Sample) <- c("Species", "Year", "Sample Size")

colnames(Significant) <- unique(unq_key$Year)

rownames(Significant) <- unique(unq_key$Common_Name)

Significant <- melt(Significant)

colnames(Significant) <- c("Species", "Year", "Significance")

colnames(mymeans) <- unique(unq_key$Year)

rownames(mymeans) <- unique(unq_key$Common_Name)

mymeans <- melt(mymeans)

colnames(mymeans) <- c("Species", "Year", "Primary Mean CPUE")

colnames(mymeans2) <- unique(unq_key$Year)

rownames(mymeans2) <- unique(unq_key$Common_Name)

mymeans2 <- melt(mymeans2)

colnames(mymeans2) <- c("Species", "Year", "Secondary Mean CPUE")

Significant_Results <- merge(Results, Significant, by = c("Species", "Year"), all = TRUE)

Small_Sample <- merge(Small, Sample, by = c("Species", "Year"), all = TRUE)

Results <- merge(Significant_Results, Small_Sample, by = c("Species", "Year"), all = TRUE)

Results <- Results[!(is.na(Results$`p-value`)) | !(is.na(Results$Significance)) | !(is.na(Results$Warning)) | !(is.na(Results$`Sample Size`)), ]

Significant <- subset(Significant_Results, Significant == "Different Means")

if(nrow(Significant) > 0) {Significant <- subset(Significant, select = c("Species", "Year", "p-value"))}

conf_names <- colnames(summary(boot_conf$bca))

Common_Names <- unique(unq_key$Common_Name)

year_names <- unique(unq_key$Year)

dimnames(conf_int)[[1]] <- as.character(unlist(Common_Names))

dimnames(conf_int)[[2]] <- as.character(unlist(conf_names))

dimnames(conf_int)[[3]] <- as.character(unlist(year_names))

conf_int <- as.data.frame(as.table(conf_int))

conf_int <- cast(conf_int, Var1 + Var3 ~ Var2, value = "Freq")

conf_int <- conf_int[c(1, 2, 6, 7)]

colnames(conf_int) <- c("Species", "Year", "Primary Lower CPUE", "Primary Upper CPUE")

dimnames(conf_int2)[[1]] <- as.character(unlist(Common_Names))

dimnames(conf_int2)[[2]] <- as.character(unlist(conf_names))

dimnames(conf_int2)[[3]] <- as.character(unlist(year_names))

conf_int2 <- as.data.frame(as.table(conf_int2))

conf_int2 <- cast(conf_int2, Var1 + Var3 ~ Var2, value = "Freq")

conf_int2 <- conf_int2[c(1, 2, 6, 7)]

colnames(conf_int2) <- c("Species", "Year", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int_all <- merge(conf_int, conf_int2, by = c("Species", "Year"), all = TRUE)

Means <- merge(mymeans, mymeans2, by = c("Species", "Year"), all = TRUE)

conf_int_all <- merge(conf_int_all, Means, by = c("Species", "Year"), all = TRUE)

conf_int_all <- na.omit(conf_int_all)

conf_int_all$`Primary Mean CPUE` <- round(conf_int_all$`Primary Mean CPUE`, 3)

conf_int_all$`Primary Lower CPUE` <- round(conf_int_all$`Primary Lower CPUE`, 3)

conf_int_all$`Primary Upper CPUE` <- round(conf_int_all$`Primary Upper CPUE`, 3)

conf_int_all$`Secondary Mean CPUE` <- round(conf_int_all$`Secondary Mean CPUE`, 3)

conf_int_all$`Secondary Lower CPUE` <- round(conf_int_all$`Secondary Lower CPUE`, 3)

conf_int_all$`Secondary Upper CPUE` <- round(conf_int_all$`Secondary Upper CPUE`, 3)

conf_int_all$`Primary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Primary Mean CPUE`, " (", conf_int_all$`Primary Lower CPUE`, ", ", conf_int_all$`Primary Upper CPUE`, ")", sep = "")

conf_int_all$`Secondary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Secondary Mean CPUE`, " (", conf_int_all$`Secondary Lower CPUE`, ", ", conf_int_all$`Secondary Upper CPUE`, ")", sep = "")

conf_int_all <- subset(conf_int_all, select = c("Species", "Year", "Primary Mean CPUE (Lower Bound, Upper Bound)", "Secondary Mean CPUE (Lower Bound, Upper Bound)"))

# Calculate the bootstrapped difference-of-means confidence intervals for
# each species and year

boot_data <- melt(CPUE_data, id.vars = c("Station", "Year", "Common_Name"))

colnames(boot_data) <- c("Station", "Year", "Common_Name", "Type", "CPUE")

diff.means <- function(d, f)
{    n <- nrow(d)
     tp1 <- 1:table(as.numeric(d$Type))[1]
     m1 <- sum(d[tp1, 5] * f[tp1])/sum(f[tp1])
     m2 <- sum(d[-tp1, 5] * f[-tp1])/sum(f[-tp1])
     ss1 <- sum(d[tp1, 5]^2 * f[tp1]) - (m1 * m1 * sum(f[tp1]))
     ss2 <- sum(d[-tp1, 5]^2 * f[-tp1]) - (m2 * m2 * sum(f[-tp1]))
     c(m1 - m2, (ss1 + ss2)/(sum(f) - 2))
}

unq_key <- unique(boot_data[,c("Year", "Common_Name")])

I <- length(unique(boot_data$Common_Name))

Y <- length(unique(boot_data$Year))

boot_result <- array(dim = c(I, 5, Y))

mean_boot <- matrix(ncol = Y, nrow = I)

for(i in 1:nrow(unq_key)){
  spec <- unq_key[i, 2]
  year <- unq_key[i, 1]
  row <- match(spec, unique(unq_key$Common_Name))
  col <- match(year, unique(unq_key$Year))
  boot_spec <- boot_data[boot_data$Year == year & boot_data$Common_Name == spec,]
  boot_spec <- na.omit(boot_spec)
  if (nrow(boot_spec) < 3) {next}
  type_boot <- boot(boot_spec, diff.means, R = 1000, strata = 
      boot_spec[ ,5])
  if(sd(type_boot$t[, 1]) != 0 & sd(type_boot$t[, 2]) != 0){
  boot_test <- boot.ci(type_boot, type = "perc")
  boot_result[row, , col] <- boot_test$perc
  }
  mean_boot[row, col] <- type_boot$t0[1]
}

# Format these results as a dataframe for output to Word

conf_name <- colnames(summary(boot_test$percent))

Common_Name <- unique(boot_data$Common_Name)

year_name <- unique(boot_data$Year)

dimnames(boot_result)[[1]] <- as.character(unlist(Common_Name))

dimnames(boot_result)[[2]] <- as.character(unlist(conf_name))

dimnames(boot_result)[[3]] <- as.character(unlist(year_name))

boot_result <- as.data.frame(as.table(boot_result))

boot_result <- cast(boot_result, Var1 + Var3 ~ Var2, value = "Freq")

boot_result <- boot_result[c(1, 2, 6, 7)]

colnames(boot_result) <- c("Species", "Year", "Lower Bound", "Upper Bound")

colnames(mean_boot) <- unique(CPUE_data$Year)

rownames(mean_boot) <- unique(CPUE_data$Common_Name)

mean_boot <- melt(mean_boot)

colnames(mean_boot) <- c("Species", "Year", "Mean Difference")

mean_boot <- na.omit(mean_boot)

boot_result <- na.omit(boot_result)

boot_result <- merge(mean_boot, boot_result, by = c("Species", "Year"), all = TRUE)

boot_result$`Mean Difference` <- signif(boot_result$`Mean Difference`, 2)

boot_result$`Lower Bound` <- signif(boot_result$`Lower Bound`, 2)

boot_result$`Upper Bound` <- signif(boot_result$`Upper Bound`, 2)

boot_result$`Mean Difference (Lower Bound, Upper Bound)` <- paste(boot_result$`Mean Difference`, " (", boot_result$`Lower Bound`, ", ", boot_result$`Upper Bound`, ")", sep = "")

boot_result <- subset(boot_result, select = c("Species", "Year", "Mean Difference (Lower Bound, Upper Bound)"))
#===============================================================
#===============================================================
```
Keywords: catch-per-unit-effort, CPUE, longlining, bootstrapping, t test, Welch's test

#Abstract

The catch per unit of effort (CPUE) is a common metric used in stock assessments. In it’s simplest form it is a unit of caught fish divided by a unit of effort. In the case of longline fishing, in which a length of groundline has a number of hooks spaced along the line, the CPUE is often the number of fish per effective hook. In calculating the CPUE, assumptions are made about hook competition, gear placement, predation, etc. In this study we use longline survey data from two fishery-independent surveys operating in the eastern North Pacific Ocean to examine one potential impact of predation. These surveys are used to inform stock assessments and each survey only reports one fish when instances of more than one fish are caught on a single hook. However, one survey records the first caught fish, while the other records the second caught fish. The purpose of this study was to examine if hooking order can impact estimates of CPUE. Two CPUE indices were calculated for each species occurring in multiple fish per hook situations: 1) based on only the first hooked fish; and 2) based only on the second hooked fish. Unequal variances T Tests on ranks, bootstrapped confidence intervals, and difference of means bootstrapped confidence intervals were used for comparing the two CPUEs. The tests largely coincided with each other, despite the small sample size in a number of the species and years. The only significant result across all 3 tests was for the octopus in the NMFS survey (n = 19, p-value = 0.00249). In general, it was found that there is no significant effect on CPUE depending on which fish is reported.

##Introduction

Fish stock assessments are based on fishery-dependent and -independent data sources, and assume that those data sources are accurate and precise (or if not, uncertainty is included). Metrics of catch, either absolute, such as total catch, or relative, such as catch-per-unit-effort (CPUE), are generally the basis for most stock assessment models. The CPUE is entirely dependent on the data reporting and estimation methods and varies greatly between gear types, fisheries, and standardizations. Thus, for stock assessments, it is critical to have an understanding of the data source and how CPUE is estimated.

There are two primary fishery-independent longline surveys operating in the Gulf of Alaska and the Bering Sea/Aleutian Islands Fishery Management Plan Areas which inform groundfish stock assessments: the International Pacific Halibut Commission (IPHC) annual halibut setline survey; and the National Marine Fisheries Service (NMFS) annual groundfish longline survey. Both surveys provide CPUE estimates of all species caught, however the data recording methods differ. 

The IPHC survey operates along the extent of the United States and Canadian west coasts and north through Alaskan waters (Goen et al. 2018). The number of stations varies slightly from year to year, and the survey has been expanding in recent years. In 2017, 1,493 stations were successfully completed. The IPHC survey samples areas of halibut habitat, and thus the stations are located in waters shallower than 500 m (i.e., continental shelf), and sometimes are near shore. Most stations consist of 5-6 skates of gear, each skate consisting of 100 16/0 baited with chum salmon and spaced 5.5 m apart. For the purposes of estimating CPUE, the relevant data recorded is the number of fish caught, the total number of hooks, the number of observed hooks and the number of observed ineffective hooks. A complete census of hooks is recorded at stations within Canadian waters, while a subsample (the first 20 hooks on each skate) is recorded at stations within U.S. waters. This 20% subsampling is sufficient to accurately extrapolate total catch for most species caught during the survey (Menon et al. 2004).

In contrast, the NMFS survey was designed to sample the slope habitat, which spans from shallow to deep (Sigler and Lunsford XX). This survey fishes 87 stations each year, with most stations ranging from 150 – 1000 m throughout the set. Each station consists of 80 skates of gear, each 100 m with 45 13/0 hooks spaced 2 m apart and baited with squid. This survey records a complete census of all hooks brought onboard, thus no extrapolation from observed catch to total catch is required. The CPUE can simply be calculated as the number caught over the number of effective hooks.

While estimating a CPUE in this manner can be quite straight forward, there are caveats. One such problem is when more than one fish occur on a single hook. This is usually the result of a predation event. A predation event can have three outcomes: 1) prey is hooked, predator attempts to or partially eats prey and is also hooked; 2) prey is hooked, predator completely eats prey and is also hooked; and 3) prey is hooked, predator eats prey but does not get hooked. Case 2 and 3 result in either only the predator on the hook or no hooked fish at all, and because it is impractical to examine the gut contents of every fish caught, observing and recording instances of Case 2 are rare (also assuming no regurgitation). Thus, Case 2 and 3 are unobservable and assumed unknown. Case 1 is observable and data do exist to examine the impact on CPUE estimates. 

Predation such as this has not previously been examined in longline survey data. The NMFS survey records only the prey (i.e., first fish hooked) and ignores any other animals on the hook even though it is usually still retained by the vessel and is thus a removal. The IPHC survey records the predator (the last animal hooked, even in cases with more than one predator) and ignores the prey animal. This case essentially treats the prey animal’s removal as a natural mortality event. The purpose of this project was to examine data from each survey to determine if the method of recording hooked animals (i.e., first or second on the hook) causes a significant change in the overall annual estimate of CPUE that might be used in stock assessments.

##Methods

Data from each survey were provided for this analysis. The NMFS survey does not record instances when more than one fish per hook occur, thus a special project was conducted during the 2014 survey to record any instances when a second fish was caught on a single hook. These data were available summarized by station. The IPHC survey has a complete census of hooks and records any instances of multiple fish per hook at all stations occurring in Canadian waters. The IPHC was able to provide the full census data for the years 2004 – 2014.

Due to the shallower depth of the stations on the IPHC survey, the catch is more diverse, 66 species, compared to the NMFS survey reporting 36 species. Some species categories were uninformative for the purpose of this study, so they were combined with other categories. For example, the “Benthic Invertebrates” category is a combination of species ranging from Sea Cucumbers to Sea Pens.

The CPUE metric used in this project was calculated as: $\frac{amount of catch}{total hooks-ineffective hooks}$ the amount of catch is all recorded catch of that species on surveyed hooks, total hooks is the number of hooks retrieved, and ineffective hooks are hooks that are bent, broken, missing, etc. The data were divided into two categories: Primary hooked fish and Secondary hooked fish. The Primary CPUE is the CPUE calculated based on the first fish on a hook and the Secondary CPUE is based on the second fish on a hook. All other instances (only one fish on a hook) exist as normal in both categories. All analyses were conducted in R [@R2017].

Mean CPUE for each species caught for each year were compared using unequal variances T Test (Welch's Test) on the ranks of the data. The unequal variances T Test performed on ranks has been shown to be robust against unequal variances and non-normally distributed data [@Ruxton2006; @Zimmerman1993]. All tests were performed at alpha = 0.05. To test for bivariate normality, QQ-plots were constructed of each variable (Primary CPUE and Secondary CPUE) as well as the residuals of a linear model of the two variables to provide a visual indicator of normality. If final test results were not significant the CPUE's were considered to have similar means, thus the catch recorded on the hook (first or second) did not affect the CPUE. This test was conducted across each species caught by the longline surveys. 7 species had 1 sample and were excluded from the tests due programming constraints on the functions performed. For visual analysis, scatterplots were also constructed of each species, plotting Secondary CPUE against Primary CPUE with a linear reference line. Bootstrapping was conducted for each species to calculate confidence intervals about the mean CPUE. For the bootstrapping procedure, we created 1000 replicates for each species and each CPUE (Primary and Secondary) and the adjusted bootstrap percentile (BCa) confidence intervals were used on this bootstrapped dataset to adjust for any bias that may exist in the data [@Efron1986]. Bootstrapped 2.5th and 97.5th confidence intervals for the difference of means between the two CPUE’s were also calculated.

##Results

The results of the unequal variances T Tests for the IPHC survey are shown in *Table 1*. The bootstrapping methods for the IPHC survey are presented in *Table 2* (BCa method) and *Table 3* (difference of means). As shown in *Table 2*, the BCa confidence intervals overlap across most of the interval between the Primary and Secondary CPUE, possessing similar lower and upper bounds and means. *Table 3* shows that the difference of means confidence intervals are largely centered on 0. The exceptions to this are the 2008 Arrowtooth Flounder, 2008 Darkblotched Rockfish (presented in the tables as Darkblotched Rkfish), and 2008 Octopus. The 2008 Darkblotched Rockfish and 2008 Octopus both show significance in the BCa confidence intervals and 2.5th and 97.5th confidence intervals, but only have a sample size of 2. So they are likely not meaningful results. In *Figure 1* and *Figure 2*, the plots and QQ-plots of certain species are presented to represent the varied quality of data in each species. The QQ-plots clearly demonstrate that some of the species violated the assumption of normality, hence the unequal variances T Test was performed on the ranks of the data rather than just the raw data.

The results of the unequal variances T Tests for the NMFS survey are shown in *Table 4*. The bootstrapping methods for the NMFS survey are presented in *Table 5* (BCa method) and *Table 6* (difference of means). It is evident in these tables that most of the species that possessed sufficient samples for analysis do not show significant results. The Octopus is the only species with significant results across all three tests [n = 19, p-value = 0.00249]. The BCa confidence intervals for the Octopus do not overlap and the 2.5th and 97.5th confidence intervals do not contain zero. Also, the Commander Skate, Greenland Turbot, Lingcod, Longnose Skate, Octopus, Pacific Cod, Sablefish, Shortspine Thornyhead, Whiteblotched Skate, and Yelloweye Rockfish 2.5th and 97.5th confidence intervals do not contain zero, though the other tests do not indicate significance. As with the IPHC survey, *Figure 3* and *Figure 4* demonstrate the varied quality of the NMFS data through plots and QQ-plots. 

##Discussion

The results shown for the IPHC survey of the unequal variances T Test indicate that there is no statistical difference between the Primary and Secondary CPUE's. Most of these results appear to fairly high p-values, though not necessarily meaningful. The primary concern with these is the power of the unequal variances T Test, given the small sample size and the generally small difference in the means of many of the samples. As such, many of the values presented in *Table 1* may be unreliable. The bootstrapping methods may be more reliable under these circumstances, though caution with these is still warranted. The results of the unequal variances T Test are supported by the overlapping BCa confidence intervals. This is again supported by the difference of means bootstrapped percentile confidence intervals most of which contain 0 in the interval, indeed most of the means are relatively close to 0. Of the results that showed significance, the 2008 Arrowtooth Flounder appears to just be an error in the 2.5th and 97.5th confidence intervals [-0.0053, -0.00035] since they do not contain 0 yet the mean is on the other side of 0 [0.00012]. The other tests did not show significance for the 2008 Arrowtooth Flounder and are likely accurate due to the sufficient sample size [n = 97]. The 2008 Darkblotched Rockfish and 2008 Octopus both show significance in the BCa confidence intervals and 2.5th and 97.5th confidence intervals, but only have a sample size of 2. So they are likely not meaningful results. This can be seen more clearly in *Figure 1* by observing the Darkblotched Rockfish plot, which clearly shows that, of the two samples, one sample had a much higher Secondary CPUE than Primary CPUE, leading to drastic results in the bootstrapping. Most of the tested species were not shown to be significantly affected by the fish counted on the hook in the event that multiple fish were on the same hook. Upon visual analysis of the scatterplots, the same conclusion can be drawn, since the plots showed that the Primary and Secondary CPUE's were identical most of the time and any deviations were noticeable, but not substantial. This is evident in *Figure 1* when observing the Lingcod, which deviates from the reference line, but only slightly.

The NMFS survey results were very similar to the IPHC survey results. The Octopus showed significant results in the NMFS survey. The species that had a 2.5th and 97.5th confidence interval that did not contain 0 are not considered significant given the results of the other two tests. The octopus showed significance for all 3 tests with a sufficient sample size [n = 19]. The deviation between the Primary and Secondary CPUE can be clearly seen in *Figure 3*. It is unclear what this indicates at this time, though the results show a greater Primary CPUE than Secondary CPUE. A possible reasoning for why most species show no dependence on which fish is recorded is that the occurrence of two fish on the same hook is relatively rare. Of the 1,482,498 hooks analyzed in this study, only 0.048% of them had secondary catch, and of the hooks that had primary catch (excluding inanimate objects and unidentified organic matter), only 0.174% had secondary catch.

###Acknowledgments

###Citations
<br>

<div id="refs" class="references"></div>

###Appendix
<br>
```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}
library(knitr, quietly = TRUE)

# Change the first NA value in each column for defining later

Results$`p-value`[match(NA, Results$`p-value`)] <- "-*"

Results$Significance <- as.character(Results$Significance)

Results$Significance[match(NA, Results$Significance)] <- "-*"

Results$Warning <- as.character(Results$Warning)

Results$Warning[match(NA, Results$Warning)] <- "-**"

# Set all other NA values to '-' and create table of results

Sub_Results <- Results[Results$`p-value` != 1,]

Sub_Results <- Sub_Results[complete.cases(Sub_Results$Species),]

options(knitr.kable.NA = '-')

kable(Sub_Results, caption = "Table 1 IPHC. All of the species analyzed in the study by year, presenting the p-value for the test performed, the significance of that test, the test used, a warning column to indicate inadequate samples, and the sample size for that species.", digits = 3, row.names = FALSE, format.args = list(na.encode = TRUE))
```

######*Not calculated due to inadequate sample size  
**No warning, sample size is greater than 1

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of the BCa confidence intervals

kable(conf_int_all, caption = "Table 2 IPHC. Bootstrapped 95% bias-corrected confidence intervals for each species by year on the Primary and Secondary CPUE.  Means are included to see the direction of bias in the samples.", digits = 4, row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of difference-of-means confidence intervals

kable(boot_result, caption = "Table 3 IPHC. Bootstrapped 95% percentile confidence intervals of the difference of means between the Primary and Secondary CPUE for each species by year.  The means are included.", row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 1 IPHC. Scatterplots of Pacific Cod, Lingcod, Octopus, and Darkblotched Rockfish with a reference line [slope = 1, intercept = 0]. Note the minor variation from the reference line in the Lingcod versus the perfect alignment on the Pacific Cod.  Also, note the low sample sizes of the Darkblotched Rockfish and Octopus. These species were chosen as a representation of the overall variation in the dataset.", fig.height = 6.5, fig.width = 6.5}

# Store data for representative species and year

dark_fish <- CPUE_data[CPUE_data$Common_Name == "Darkblotched Rkfish" & CPUE_data$Year == "2007",]

pac_cod <- CPUE_data[CPUE_data$Common_Name == "Pacific Cod" & CPUE_data$Year == "2007",]

lin_cod <- CPUE_data[CPUE_data$Common_Name == "Lingcod" & CPUE_data$Year == "2007",]

oct_pus <- CPUE_data[CPUE_data$Common_Name == "Octopus" & CPUE_data$Year == "2007",]

# Output plots of species into a single figure with reference lines

par(mfrow = c(2, 2))

with(pac_cod, plot(Primary_CPUE, Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(Primary_CPUE) + .001), ylim = 
        c(0, max(Secondary_CPUE) + .001), main = 
        paste("Plot of Pacific Cod 2007")))

abline(a = 0, b = 1, lty = 3)

with(lin_cod, plot(Primary_CPUE, Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(Primary_CPUE) + .001), ylim = 
        c(0, max(Secondary_CPUE) + .001), main = 
        paste("Plot of Lingcod 2007")))

abline(a = 0, b = 1, lty = 3)

with(oct_pus, plot(Primary_CPUE, Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(Primary_CPUE) + .001), ylim = 
        c(0, max(Secondary_CPUE) + .001), main = 
        paste("Plot of Octopus 2007")))

abline(a = 0, b = 1, lty = 3)

with(dark_fish, plot(Primary_CPUE, Secondary_CPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(Primary_CPUE) + .001), ylim = 
        c(0, max(Secondary_CPUE) + .001), main = 
        paste("Plot of Darblotched Rockfish 2007")))

abline(a = 0, b = 1, lty = 3)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 2 IPHC.  QQ-plots demonstrating the non-normality of the data for Pacific Cod (left 3 plots) and Lingcod (right 3 plots).  There is a greater deviation in the Pacific Cod than the Lingcod plots. These species were chosen to demonstrate the variation in the dataset", fig.height = 5, fig.width = 6.5}

# Create a linear model of the representative species CPUE's

model <- lm(formula = Secondary_CPUE ~ Primary_CPUE, data = pac_cod)

model2 <- lm(formula = Secondary_CPUE ~ Primary_CPUE, data = lin_cod)

# Output QQ-plots of species in a single figure with reference lines

layout(mat = matrix(c(1,2,4,5,3,3,6,6), nrow = 2, ncol = 4, byrow = TRUE))

with(pac_cod, qqnorm(Primary_CPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nPrimary CPUE \nPacific Cod 2004"))

with(pac_cod, qqline(Primary_CPUE, lty = 3))

with(pac_cod, qqnorm(Secondary_CPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nSecondary CPUE \nPacific Cod 2004"))

with(pac_cod, qqline(Secondary_CPUE, lty = 3))

with(pac_cod, qqnorm(residuals(model), ylim = c(-0.5,0.5), main = "QQ-plot of Residuals obtained from \nSimple Regression Model \nPacific Cod 2004"))

with(pac_cod, qqline(residuals(model), lty = 3))

with(lin_cod, qqnorm(Primary_CPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nPrimary CPUE \nLingcod 2008"))

with(lin_cod, qqline(Primary_CPUE, lty = 3))

with(lin_cod, qqnorm(Secondary_CPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nSecondary CPUE \nLingcod 2008"))

with(lin_cod, qqline(Secondary_CPUE, lty = 3))

with(lin_cod, qqnorm(residuals(model2), ylim = c(-0.5,0.5), main = "QQ-plot of Residuals obtained from \nSimple Regression Model \nLingcod 2008"))

with(lin_cod, qqline(residuals(model2), lty = 3))
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE}

#===============================================================
#===============================================================
# NMFS Analysis

# Load relevant Excel files

catch_data <- read.csv("NMFS_Data/ABL_2014_multi.csv", na.strings = "", header = TRUE)

catch_codes <- read.csv("NMFS_Data/Species_Catch_Codes.csv", na.strings = "", header = 
    TRUE)

names(catch_codes)[3:6] <- c("Polycorder_Number", "Species_Code", "Common_Name", "Scientific_Name")

catch_full <- read.csv("NMFS_Data/ABL_2014_full.csv", na.strings = "", header = TRUE)

names(catch_full)[c(6, 44, 45, 51)] <- c("Station_Number", "Species_Code", "Common_Name", "Ineffective_Hooks")

# Combine the multi dataset and catch codes to convert the polycorder numbers to species codes
# for Primary and Secondary catch

catch_data <- merge(catch_data, catch_codes, by.x = "Primary", by.y = 
    "Polycorder_Number", all.x = TRUE)

catch_data <- subset(catch_data, select = c("Station", "Species_Code", 
    "Secondary"))

colnames(catch_data)[colnames(catch_data) == "Species_Code"] <- "Primary"

catch_data <- merge(catch_data, catch_codes, by.x = "Secondary", by.y = 
    "Polycorder_Number", all.x = TRUE)

catch_data <- subset(catch_data, select = c("Station", "Primary", 
    "Species_Code"))

colnames(catch_data)[colnames(catch_data) == "Species_Code"] <- 
    "Secondary"

# Obtain unique list of species from the Primary and Secondary catch

speclist <- unique(c(catch_data$Primary, catch_data$Secondary))

# Extract all data for each species in the species list from the full dataset

species_data <- catch_full[(catch_full$Species_Code%in%speclist), 
    c("Station_Number", "Species_Code", "Common_Name", "Catch", "Hachi", 
    "Ineffective_Hooks")]

# Obtain the maximum number of Hachi from each station

station <- as.data.frame(with(species_data, tapply(Hachi, list(Station_Number), max)))

station$number <- as.numeric(rownames(station))

rownames(station)<-NULL

colnames(station) <- c("maxHachi", "Station")

# Obtain the total number of hooks from each station

station$tothks <- station$maxHachi*45

# Obtain the number of ineffective hooks from each station and add to station data

hachks <- as.data.frame(with(species_data, tapply(Ineffective_Hooks, list(Station_Number, Hachi), mean)))

ineffhks <- rowSums(hachks, na.rm = TRUE)

station <- cbind(station, ineffhks)

# Calculate the catch for each species at each station from the full dataset

spec_catch <- cast(species_data, Station_Number ~ Species_Code, sum, value = 
    "Catch")

# Combine the station and species catch data

catch_data2 <- merge(station, spec_catch, by.x = "Station", by.y = 
    "Station_Number")

# Reformat to a more usable form

catch_data3 <- melt(catch_data2, id = c("Station", "maxHachi", "tothks",
    "ineffhks"))

colnames(catch_data3) <- c("Station", "maxHachi", "tothks", "ineffhks", 
    "Species", "Catch")

# Calculate the primary catch for each species at each station for the multi dataset

pri_data <- count(catch_data, c("Station", "Primary"))

pri_data2 <- cast(pri_data, Station ~ Primary, sum, value = "freq")

pri_data3 <- melt(pri_data2, id = "Station")

colnames(pri_data3) <- c("Station", "Primary_Catch", "Species")

# Combine the calculated catches to get the full primary catch

catch_data4 <- join(catch_data3, pri_data3, type = "full")

catch_data4[is.na(catch_data4)] <- 0

catch_data4$priCatch <- rowSums(catch_data4[c("Catch", "Primary_Catch")])

# Calculate the primary CPUE

catch_data4$priCPUE <- catch_data4$priCatch / (catch_data4$tothks - 
   catch_data4$ineffhks)

# Calculate the secondary catch for each species at each station for the multi dataset

sec_data <- count(catch_data, c("Station", "Secondary"))

sec_data2 <- cast(sec_data, Station ~ Secondary, sum, value = "freq")

sec_data3 <- melt(sec_data2, id = "Station")

colnames(sec_data3) <- c("Station", "Secondary_Catch", "Species")

# Combine the calculated catches to get secondary catch (ommitting primary catch from multi dataset)

catch_data5 <- join(catch_data4, sec_data3, type = "full")

catch_data5[is.na(catch_data5)] <- 0

catch_data5$secCatch <- rowSums(catch_data5[c("Catch", "Secondary_Catch")])

catch_data5 <- catch_data5[order(catch_data5$Station),]

# Calculate the secondary CPUE

catch_data5$secCPUE <- catch_data5$secCatch / (catch_data5$tothks - 
    catch_data5$ineffhks)

# Remove species not found in species catch codes and any 0 catch values

catch_data5$Species[catch_data5$Species == "30051"] <- NA

catch_data5$Catch[catch_data5$Catch == 0] <- NA

catch_data5 <- na.omit(catch_data5)

catch_full <- rename(catch_full, replace = c("Species_Code" = "Species"))

# Obtain a list of the unique species from the full dataset

uniq_spec <- unique(catch_full$Species)

uniq_spec_frame <- data.frame(uniq_spec)

colnames(uniq_spec_frame)[colnames(uniq_spec_frame) == "uniq_spec"] <- "Species"

# Combine with full dataset for unique list of species common names matched to species codes

uniq_spec_name <- join(uniq_spec_frame, catch_full, by = "Species", type = "left", match = "first")

uniq_spec_name[c(2:44, 46:52)] <- list(NULL)

# Combine species name list with calculated data frame

catch_data6 <- merge(catch_data5, uniq_spec_name, by = "Species")

catch_data6 <- subset(catch_data6, select = c("Station", "priCPUE", "secCPUE", "Common_Name"))

catch_data6$Common_Name <- as.character(catch_data6$Common_Name)

catch_data6$Common_Name[catch_data6$Common_Name == "Aleutian/Bering/Alaska Skate Complex"
                      ] <- "Aleutian Bering Alaska Skate Complex"

# Prepare any objects for use inside the for-loop

Results <- NULL

Small <- NULL

Significant <- NULL

Sample <- NULL

Test <- NULL

mymeans <- NULL

mymeans2 <- NULL

CPUE_rank <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

conf_int2 <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

# Create scatterplots, QQ-plots, perform the Welch's T-Test on ranks, and
# create bootstrapped confidence intervals for each species
for(i in unique(catch_data6$Common_Name)){
  CPUE_spec <- subset(catch_data6, catch_data6$Common_Name == i)
  jpeg(paste("NMFS_Data/Plots/", i,".jpg", sep = ""))
  plot(CPUE_spec$priCPUE, CPUE_spec$secCPUE, type = "p", xlab = 
         paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
         c(0, max(CPUE_spec$priCPUE) + .001), ylim = 
         c(0, max(CPUE_spec$secCPUE) + .001), main = 
         paste("Plot of", i))
  abline(a = 0, b = 1, lty = 3)
  dev.off()
  Sample[i] <- nrow(CPUE_spec)
  if(nrow(CPUE_spec) == 1) {
    Small[i] <- paste("Small Sample Size")
    next
  } else {
    mymean <- function(priCPUE, j) mean(priCPUE[j])
    myboot <- with(CPUE_spec, boot(priCPUE, mymean, R = 1000))
    if(sd(myboot$t) != 0){
      boot_conf <- boot.ci(myboot, type = "bca")
      conf_int[i, ] <- boot_conf$bca
    }
    mymeans[i] <- myboot$t0
    mymean2 <- function(secCPUE, j) mean(secCPUE[j])
    myboot2 <- with(CPUE_spec, boot(secCPUE, mymean2, R = 1000))
    if(sd(myboot2$t) != 0){
      boot_conf2 <- boot.ci(myboot2, type = "bca")
      conf_int2[i, ] <- boot_conf2$bca
    }
    mymeans2[i] <- myboot2$t0
    model <- lm(formula = secCPUE ~ priCPUE, data = CPUE_spec)
    png(paste("NMFS_Data/Plots/QQof",i,".png", sep = ""))
    layout(rbind(c(1,2), c(3,3)))
    qqnorm(CPUE_spec$priCPUE, ylim = c(-0.5,0.5), main = 
             "QQ-plot of Primary CPUE \n", i)
    qqline(CPUE_spec$priCPUE, lty = 3)
    qqnorm(CPUE_spec$secCPUE, ylim = c(-0.5,0.5), main = 
             "QQ-plot of Secondary CPUE \n", i)
    qqline(CPUE_spec$secCPUE, lty = 3)
    qqnorm(residuals(model), ylim = c(-0.5,0.5),
           main = "QQ-plot of Residuals obtained from \nSimple Regression",
           "Model \n", i)
    qqline(residuals(model), lty = 3)
    dev.off()
    if(sd(myboot$t) != 0 | sd(myboot2$t) != 0){
      CPUE_rank <- melt(CPUE_spec, id.vars = c("Station", "Common_Name"))
      colnames(CPUE_rank) <- c("Station", "Common_Name", "Type", "CPUE")
      CPUE_rank$CPUE <- with(CPUE_rank, rank(CPUE, ties.method = "average"))
      CPUE_rank <- cast(CPUE_rank, Station + Common_Name ~ Type, 
                        value = "CPUE")
      result <- with(CPUE_rank, t.test(priCPUE, secCPUE, var.equal = FALSE))
    if (result$p.value < 0.05) {
      Significant[i] <- paste("Different Means")
    } else {
      Significant[i] <- paste("Similar Means")}
      Results[i] <- result$p.value
    }
  }
}

# Format all of the results into various dataframes for output into an Excel
# file

Results <- data.frame(Results)

Significant <- data.frame(Significant)

Small <- data.frame(Small)

Sample <- data.frame(Sample)

Means <- data.frame(mymeans)

Means2 <- data.frame(mymeans2)

Significant_Results <- merge(Results, Significant, by = "row.names", all = TRUE)

Small_Sample <- merge(Small, Sample, by = "row.names", all = TRUE)

Results <- merge(Significant_Results, Small_Sample, by = "Row.names", all = TRUE)

if(nrow(Small) > 0){
  colnames(Results) <- c("Species", "p-value", "Significance", "Warning", "Sample Size")
} else {
  colnames(Results) <- c("Species", "p-value", "Significance", "Sample Size")
}

Significant <- subset(Significant_Results, Significant == "Different Means")

if(nrow(Significant) > 0) {colnames(Significant) <- c("Species", "p-value", "Significant")
  Significant <- subset(Significant, select = c("Species", "p-value"))}

colnames(conf_int) <- c("Levels", "Unk", "Unk2", "Primary Lower CPUE", "Primary Upper CPUE")

colnames(conf_int2) <- c("Levels", "Unk", "Unk2", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int <- subset(conf_int, select = c("Primary Lower CPUE", "Primary Upper CPUE"))

conf_int <- na.omit(conf_int)

conf_int2 <- subset(conf_int2, select = c("Secondary Lower CPUE", "Secondary Upper CPUE"))

conf_int2 <- na.omit(conf_int2)

conf_int_all <- merge(conf_int, conf_int2, by = "row.names", all = TRUE)

means_all <- merge(Means, Means2, by = "row.names", all = TRUE)

colnames(means_all) <- c("Species", "Primary Mean CPUE", "Secondary Mean CPUE")

colnames(conf_int_all) <- c("Species", "Primary Lower CPUE", "Primary Upper CPUE", "Secondary Lower CPUE", "Secondary Upper CPUE")

conf_int_all <- merge(conf_int_all, means_all, by = "Species", all = TRUE)

conf_int_all$`Primary Mean CPUE` <- round(conf_int_all$`Primary Mean CPUE`, 4)

conf_int_all$`Primary Lower CPUE` <- round(conf_int_all$`Primary Lower CPUE`, 4)

conf_int_all$`Primary Upper CPUE` <- round(conf_int_all$`Primary Upper CPUE`, 4)

conf_int_all$`Secondary Mean CPUE` <- round(conf_int_all$`Secondary Mean CPUE`, 4)

conf_int_all$`Secondary Lower CPUE` <- round(conf_int_all$`Secondary Lower CPUE`, 4)

conf_int_all$`Secondary Upper CPUE` <- round(conf_int_all$`Secondary Upper CPUE`, 4)

conf_int_all$`Primary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Primary Mean CPUE`, " (", conf_int_all$`Primary Lower CPUE`, ", ", conf_int_all$`Primary Upper CPUE`, ")", sep = "")

conf_int_all$`Secondary Mean CPUE (Lower Bound, Upper Bound)` <- paste(conf_int_all$`Secondary Mean CPUE`, " (", conf_int_all$`Secondary Lower CPUE`, ", ", conf_int_all$`Secondary Upper CPUE`, ")", sep = "")

conf_int_all <- subset(conf_int_all, select = c("Species", "Primary Mean CPUE (Lower Bound, Upper Bound)", "Secondary Mean CPUE (Lower Bound, Upper Bound)"))

# Calculate the bootstrapped difference-of-means confidence intervals for
# each species

boot_data <- melt(catch_data6, id.vars = c("Station", "Common_Name"))

colnames(boot_data) <- c("Station", "Common_Name", "Type", "CPUE")

diff.means <- function(d, f)
{    n <- nrow(d)
tp1 <- 1:table(as.numeric(d$Type))[1]
m1 <- sum(d[tp1, 4] * f[tp1])/sum(f[tp1])
m2 <- sum(d[-tp1, 4] * f[-tp1])/sum(f[-tp1])
ss1 <- sum(d[tp1, 4]^2 * f[tp1]) - (m1 * m1 * sum(f[tp1]))
ss2 <- sum(d[-tp1, 4]^2 * f[-tp1]) - (m2 * m2 * sum(f[-tp1]))
c(m1 - m2, (ss1 + ss2)/(sum(f) - 2))
}

boot_result <- as.data.frame(matrix(NA, ncol = 5, nrow = 1))

diff_mean_results <- NULL

for(i in unique(boot_data$Common_Name)){
  boot_spec <- subset(boot_data, boot_data$Common_Name == i)
  if (nrow(boot_spec) < 3) {next}
  type_boot <- boot(boot_spec, diff.means, R = 1000, strata = boot_spec[ ,4])
  if(sd(type_boot$t[, 1]) != 0 & sd(type_boot$t[, 2]) != 0){
    boot_test <- boot.ci(type_boot, type = "perc")
    boot_result[i, ] <- boot_test$perc
  }
  diff_mean_results[i] <- type_boot$t0[1]
}

# Format these results as a dataframe for output to Excel

boot_result <- subset(boot_result, select = c("V4", "V5"))

diff_mean_results <- data.frame(diff_mean_results)

boot_result <- na.omit(boot_result)

boot_result <- merge(diff_mean_results, boot_result, by = "row.names", all = TRUE)

colnames(boot_result) <- c("Species", "Mean Difference", "Lower Bound", "Upper Bound")

boot_result$`Mean Difference` <- signif(boot_result$`Mean Difference`, 2)

boot_result$`Lower Bound` <- signif(boot_result$`Lower Bound`, 2)

boot_result$`Upper Bound` <- signif(boot_result$`Upper Bound`, 2)

boot_result$`Mean Difference (Lower Bound, Upper Bound)` <- paste(boot_result$`Mean Difference`, " (", boot_result$`Lower Bound`, ", ", boot_result$`Upper Bound`, ")", sep = "")

boot_result <- subset(boot_result, select = c("Species", "Mean Difference (Lower Bound, Upper Bound)"))
#===============================================================
#===============================================================
```

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Change the first NA value in each column for defining later

Results$`p-value`[match(NA, Results$`p-value`)] <- "-*"

Results$Significance <- as.character(Results$Significance)

Results$Significance[match(NA, Results$Significance)] <- "-*"

Results$Warning <- as.character(Results$Warning)

Results$Warning[match(NA, Results$Warning)] <- "-**"

# Set all other NA values to '-' and create table of results

options(knitr.kable.NA = '-')

kable(Results, caption = "Table 4 NMFS. All of the species analyzed in the study, presenting the p-value for the test performed, the significance of that test, the test used, a warning column to indicate inadequate samples, and the sample size for that species.", digits = 3, row.names = FALSE, format.args = list(na.encode = TRUE))
```

######*Not calculated due to inadequate sample size  
**No warning, sample size is greater than 1

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of the BCa confidence intervals

kable(conf_int_all, caption = "Table 5 NMFS. Bootstrapped 95% bias-corrected confidence intervals for each species on the Primary and Secondary CPUE. Means are included to see the direction of bias in the samples.", digits = 4, row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}

# Create a table of difference-of-means confidence intervals

kable(boot_result, caption = "Table 6 NMFS. Bootstrapped 95% percentile confidence intervals of the difference of means between the Primary and Secondary CPUE. The means are included.", row.names = FALSE)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 3 NMFS. Scatterplots of Pacific Cod, Lingcod, Octopus, and Shortspine Thornyhead with a reference line [slope = 1, intercept = 0]. Note the variation from the reference line in the Lingcod versus the perfect alignment on the Pacific Cod.  Also, note the low sample sizes of the Tanner Crab unident. and Octopus. These species were chosen as a representation of the overall variation in the dataset.", fig.height = 6.5, fig.width = 6.5}

# Store data for representative species and year

lin_cod <- catch_data6[catch_data6$Common_Name == "Lingcod",]

pac_cod <- catch_data6[catch_data6$Common_Name == "Pacific cod",]

short_thorn <- catch_data6[catch_data6$Common_Name == "Shortspine thornyhead",]

oct_pus <- catch_data6[catch_data6$Common_Name == "Octopus",]

# Output plots of species into a single figure with reference lines

par(mfrow = c(2, 2))

with(pac_cod, plot(priCPUE, secCPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(priCPUE) + .001), ylim = 
        c(0, max(secCPUE) + .001), main = 
        paste("Plot of Pacific Cod")))

abline(a = 0, b = 1, lty = 3)

with(lin_cod, plot(priCPUE, secCPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(priCPUE) + .001), ylim = 
        c(0, max(secCPUE) + .001), main = 
        paste("Plot of Lingcod")))

abline(a = 0, b = 1, lty = 3)

with(oct_pus, plot(priCPUE, secCPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(priCPUE) + .001), ylim = 
        c(0, max(secCPUE) + .001), main = 
        paste("Plot of Octopus")))

abline(a = 0, b = 1, lty = 3)

with(short_thorn, plot(priCPUE, secCPUE, type = "p", xlab = 
        paste("Primary CPUE"), ylab = paste("Secondary CPUE"), xlim = 
        c(0, max(priCPUE) + .001), ylim = 
        c(0, max(secCPUE) + .001), main = 
        paste("Plot of Shortspine Thornyhead")))

abline(a = 0, b = 1, lty = 3)
```

####

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Figure 4 NMFS.  QQ-plots demonstrating the non-normality of the data for Pacific Cod (left 3 plots) and Lingcod (right 3 plots).  There is a greater deviation in the Pacific Cod than the Lingcod plots. These species were chosen to demonstrate the variation in the dataset", fig.height = 5, fig.width = 6.5}

# Create a linear model of the representative species CPUE's

model <- lm(formula = secCPUE ~ priCPUE, data = pac_cod)

model2 <- lm(formula = secCPUE ~ priCPUE, data = lin_cod)

# Output QQ-plots of species in a single figure with reference lines

layout(mat = matrix(c(1,2,4,5,3,3,6,6), nrow = 2, ncol = 4, byrow = TRUE))

with(pac_cod, qqnorm(priCPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nPrimary CPUE \nPacific Cod"))

with(pac_cod, qqline(priCPUE, lty = 3))

with(pac_cod, qqnorm(secCPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nSecondary CPUE \nPacific Cod"))

with(pac_cod, qqline(secCPUE, lty = 3))

with(pac_cod, qqnorm(residuals(model), ylim = c(-0.5,0.5), main = "QQ-plot of Residuals obtained from \nSimple Regression Model \nPacific Cod"))

with(pac_cod, qqline(residuals(model), lty = 3))

with(lin_cod, qqnorm(priCPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nPrimary CPUE \nLingcod"))

with(lin_cod, qqline(priCPUE, lty = 3))

with(lin_cod, qqnorm(secCPUE, ylim = c(-0.5,0.5), main = "QQ-plot of \nSecondary CPUE \nLingcod"))

with(lin_cod, qqline(secCPUE, lty = 3))

with(lin_cod, qqnorm(residuals(model2), ylim = c(-0.5,0.5), main = "QQ-plot of Residuals obtained from \nSimple Regression Model \nLingcod"))

with(lin_cod, qqline(residuals(model2), lty = 3))
```
